//scala def l(s:String) = { "(l:"+s+")" }
//scala 
//scala def nitm(nt:String,i:String,as:String,k:String,bs:String) = {
//scala   s"""latexmath:[( $nt \\rightarrow {}_{$i} $as {}_{$k} . $bs)]"""
//scala }
//scala 
//scala def nitm_trad (nt:String,i:String,as:String,k:String,bs:String) = {
//scala   s"""latexmath:[( $nt \\rightarrow $as . $bs, $i, $k)]"""
//scala }
//scala 
//scala val x = "X"
//scala val as = "\\alpha"
//scala val bs = "\\beta"
//scala 
//scala val i = "i"
//scala val k = "k"
//scala val j = "j"
//scala val s = "S"
//scala val t = "T"
//scala 
//scala val nt_item = "`nt_item`"
//scala val tm_item = "`tm_item`"
//scala 
//scala def titm(k:String,t:String,j:String) = {
//scala   s"""latexmath:[( {}_{$k} ${t}_{$j})]"""
//scala }
//scala 
//scala def titm(k:String,t:String) = {
//scala   s"""latexmath:[( {}_{$k} ${t}_{?})]"""
//scala }
//scala 
//scala def citm(k:String,s:String,j:String) = {
//scala   s"""latexmath:[( {}_{$k} ${s}_{$j})]"""
//scala }
//scala 
//scala 
//scala val adoc = s"""
= Simple Earley Parsing: unstaged, terminals uncached
Author: Tom Ridge
:stem: latexmath
:source-highlighter: pygments

File: e_cn_inline_comments.ml

== Meta

HTML preview: http://htmlpreview.github.io/?https://github.com/tomjridge/simple_earley/blob/master/src/e_cn_inline_comments.pp.html

We work with `nt_items` only (terminal parses are not cached). No
staging. latexmath:[O(n^3)].

We define the map types that we need. From a set of
complete items, we need to identify those for a given start index and
symbol. This is the role of the complete map type `cm_t`. The codomain
of the map is a set of integers latexmath:[j]. If latexmath:[j \\in
cm(k,S)] then there is a complete item ${citm(k,s,j)}.

The blocked map allows us to identify, from a set of nt items, those
that are currently blocked at position latexmath:[k] waiting for a parse of
symbol latexmath:[S] to complete. latexmath:[nitm \\in bm(k,S)] if latexmath:[nitm] is of the form ${nitm(x,i,as,k,s"S $bs")}.

[source,ocaml]
----
//ml (* Earley, nt_items only, unstaged, O(n^3) *)
//ml 
//ml open E_common
//ml open E_common.Unstaged
//ml 
//ml let comp = Pervasives.compare
//ml 
//ml module Blocked_map =
//ml   Map.Make(struct type t = b_key_t;; let compare: t -> t -> int = comp end)
//ml 
//ml module Complete_map =
//ml   Map.Make(struct type t = c_key_t;; let compare: t -> t -> int = comp end)
//ml 
//ml 
//ml type cm_t = Int_set.t option Complete_map.t
//ml type bm_t = Nt_item_set.t Blocked_map.t
//ml 
//ml (* add some defaults *)
//ml 
//ml let cm_find k m = try Complete_map.find k m with Not_found -> Some(Int_set.empty) (* FIXME add note about option *)
//ml let bm_find k m = try Blocked_map.find k m with Not_found -> Nt_item_set.empty
//ml 
----

The state of the Earley algorithm is represented as a record with the
following fields:


* `todo_done` is the set of all items that are pending, or have
  already been processed
* `todo` is the list of all items that are pending
* `blocked` is the blocked map
* `complete` is the complete map

[source,ocaml]
----
//ml 
//ml type state_t = {
//ml     todo_done: Nt_item_set.t;
//ml     todo: nt_item list;
//ml     blocked: bm_t;
//ml     complete: cm_t
//ml   }
//ml 
----

We add an item to the state by adding it to `todo` and
`todo_done`. If the item is already in `todo_done` we leave the state
unchanged.

[source,ocaml]
----
//ml 
//ml let add_todo: nt_item -> state_t -> state_t = (
//ml     fun itm s0 -> (
//ml       match (Nt_item_set.mem itm s0.todo_done) with
//ml       | true -> s0
//ml       | false -> {s0 with
//ml                    todo_done=(Nt_item_set.add itm s0.todo_done);
//ml                    todo=(itm::s0.todo) }    )  )
//ml 
----

Now we implement the core Earley step. This takes a blocked
item ${nitm(x,i,as,k,s"S $bs")} and a complete item ${citm(k,s,j)} and
forms a new item of the form ${nitm(x,i,s"$as S",j,bs)}. Note that the
latexmath:[$as] field is stored in "reverse" order (to make this
operation more efficient).

Notation: latexmath:[S $bs] is the list latexmath:[$bs] with latexmath:[S] cons'ed on. latexmath:[$as S] is the
list latexmath:[$as] with latexmath:[S] joined on the end.

----
X -> i,as,k,(S bs)   k S j
------------------------- cut
X -> i,(as S),j,bs
----


[source,ocaml]
----
//ml 
//ml let cut: nt_item -> j_t -> nt_item = (
//ml     fun bitm j0 -> (
//ml       let as_ = (List.hd bitm.bs)::bitm.as_ in
//ml       let bs = List.tl bitm.bs in
//ml       let k = j0 in
//ml       let nitm ={bitm with k;as_;bs} in
//ml       nitm ))
//ml 
----

We then give definitions for adding a complete item to the complete
map, and a blocked item to the blocked map.

[source,ocaml]
----
//ml 
//ml let citm_to_key = (fun citm -> (citm.k,citm.sym))
//ml 
//ml let c_add: citm_t -> cm_t -> cm_t = (
//ml     fun citm cm -> (
//ml       let key = citm_to_key citm in
//ml       (*  invariant: anything in the map is Some(...); FIXME so why have option type? *)
//ml       let s = (cm_find key cm) |> dest_Some in
//ml       let s' = Int_set.add citm.j s in
//ml       let cm' = Complete_map.add key (Some s') cm in
//ml       cm' ))
//ml 
//ml let bitm_to_key = (fun (bitm:bitm_t) -> (bitm.k,List.hd bitm.bs))
//ml 
//ml let b_add: bitm_t -> bm_t -> bm_t = (
//ml     fun bitm bm -> (
//ml       let key = bitm_to_key bitm in
//ml       let s = bm_find key bm in
//ml       let s' = Nt_item_set.add bitm s in
//ml       let bm' = Blocked_map.add key s' bm in
//ml       bm' ))
//ml 
----

We pull out some common code `process_citms` to process a list of complete
items, all of which have a given key. Processing involves adding each
`citm` to the complete map, and cutting each item against the relevant
blocked items.


[source,ocaml]
----
//ml 
//ml (* process citms; update complete map; cut against blocked items *)
//ml 
//ml let process_citms key citms s0 = (
//ml     let f5 s1 citm = 
//ml       { s1 with complete=(c_add citm s1.complete) } in
//ml     let s0 = while_not_nil citms s0 f5 in
//ml     (* cut citm against blocked *)
//ml     let bitms = bm_find key s0.blocked in
//ml     let f8 s1 citm = (
//ml         let f6 bitm s1 = (let nitm = cut bitm citm.j in add_todo nitm s1) in
//ml         let s1 = Nt_item_set.fold f6 bitms s1 in
//ml         s1)
//ml     in
//ml     let s0 = while_not_nil citms s0 f8 s0 citms in
//ml     s0 )
//ml 
----

Now we reach the core `step` part of Earley's algorithm. The
full algorithm repeatedly applies `step` to an initial state until
there are no further `todo` items.

[source,ocaml]
----
//ml 
//ml let step: ctxt_t -> state_t -> state_t = (
//ml     fun c0 s0 -> (
//ml       match s0.todo with
//ml       | [] -> s0  (* finished *)
//ml       | nitm::rest -> (
//ml         (* process itm *)
//ml         let s0 = { s0 with todo=rest } in
//ml         let complete = (nitm.bs = []) in

----

We are processing an nt item. This item may be complete. If
so, via `process_citms` we record it in the complete map, and process
it against any blocked items with the same key.

[source,ocaml]
----


//ml         match complete with
//ml         | true -> (
//ml           let (k,sym,j) = (nitm.i,NT(nitm.nt),nitm.k) in
//ml           let citm : citm_t = {k;sym;j} in
//ml           let key = citm_to_key citm in
//ml           process_citms key [citm] s0
//ml         )
//ml         | false -> (  (* l:kl *)
//ml 
----

The nt item is not complete. So we record it in the blocked
map. 

[source,ocaml]
----
//ml 
//ml           (* blocked, so process next sym *)
//ml           let bitm = nitm in
//ml           let (k,sym) = (bitm.k,List.hd nitm.bs) in
//ml           let key = (k,sym) in
//ml           (* record bitm *)
//ml           let s0 = { s0 with blocked=(b_add bitm s0.blocked) } in
----

We then try to progress the item by cutting it with all the
current complete items with the same key. 

[source,ocaml]
----
//ml           (* process blocked against complete items *)
//ml           let f2 j s1 = (let nitm = cut bitm j in add_todo nitm s1) in
//ml           let js = (cm_find key s0.complete) |> dest_Some in
//ml           let s0 = Int_set.fold f2 js s0 in
//ml           (* now look at symbol we are blocked on *)  (* l:lm *)
//ml 
----

It may be that we have yet
to process all or any of the relevant complete items. So we also have
to look at the symbol the nt item is blocked on, and manufacture more
items. 

[source,ocaml]
----
//ml 
//ml           match sym with
//ml           | NT nt -> (
//ml             let nitms = c0.g0.nt_items_for_nt nt (c0.i0.str,k) in
//ml             let f3 s1 nitm = (add_todo nitm s1) in
//ml             let s0 = while_not_nil nitms s0 f3 in
//ml             s0
//ml           )
//ml           | TM tm -> (
----

The nt item was blocked on a terminal `tm` (or latexmath:[T]). We use `p_of_tm` to
determine which substrings of the input can be parsed as the terminal
latexmath:[T]. This gives us complete items of the form ${citm(k,t,j)}. For each
`citm` we then update the complete map and process against blocked
items, using `process_citms`.

There is a possible optimization here: if the key is already in the
complete map, we don't need to process it again. For simplicity we
don't incorporate this optimization.

[source,ocaml]
----
//ml             let k = nitm.k in
//ml             let p = c0.g0.p_of_tm tm in
//ml             let js = p (c0.i0.str,k,c0.i0.len) in
//ml             let citms = List.map (fun j -> {k;sym;j}) js in
//ml             let key = (k,sym) in
//ml             process_citms key citms s0 )))))
//ml 
----

That concludes the explanation of the core of the algorithm.

Next we repeatedly apply the step function in a loop until there
are no more items to do.

[source,ocaml]
----
//ml 
//ml let rec earley' ctxt s0 = (
//ml     if s0.todo = [] then s0 else earley' ctxt (step ctxt s0))
//ml 
//ml let cn_earley c0 nt = (
//ml     let (i,k) = (0,0) in
//ml     let init = {nt;i;as_=[];k;bs=[NT nt]} in
//ml     let todo = [init] in
//ml     let todo_done = Nt_item_set.empty in
//ml     let blocked = Blocked_map.empty in
//ml     let complete = Complete_map.empty in
//ml     let s0 = {todo; todo_done; blocked; complete} in
//ml     let s1 = earley' c0 s0 in
//ml     s1)
//ml 
----


== Complexity

We assume that there is a constant latexmath:[c] such that each invocation of
`p_of_tm` produces at most latexmath:[c * n] results.

As implemented, the algorithm is latexmath:[O(n^{3}\\ log\\ n)] because the sets and
maps use OCaml's default sets and maps, which are implemented as
binary trees. However, clearly given an input and a grammar, there are
only a finite number of items that can be in any of the sets or
maps. Thus, we can enumerate these items, and use the enumeration to
implement e.g. a set as an array. This would give the latexmath:[O(n^3)] desired
complexity.

//scala """
//scala 
//scala val adoc2 = adoc.lines.map(s => 
//scala   if (s.startsWith("//adoc ")) s.substring(7) 
//scala   else if (s.startsWith("//ml ")) s.substring(5)
//scala   else s).mkString("\n")
//scala 
//scala // write doc to README.scala.adoc
//scala 
//scala import java.io._
//scala 
//scala new PrintWriter("e_cn_inline_comments.pp.adoc") { write(adoc2); close }