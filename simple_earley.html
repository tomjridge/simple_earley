<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="simple-implementation-of-an-earley-like-parsing-algorithm">Simple implementation of an Earley-like parsing algorithm</h1>
<h2 id="meta">Meta</h2>
<p>This document explains the OCaml code in <code>simple_earley.ml</code>. An html version of the code is in <code>simple_earley.ml.html</code> or possibly <a href="simple_earley.ml.html">here</a>.</p>
<p>The code is a minimal implementation of an Earley-like parsing algorithm.</p>
<p>The source for this file is <code>simple_earley.md</code>. This markdown file can be processed with pandoc. An html version of this doc is in <code>simple_earley.html</code>.</p>
<p>References to the code are of the form <code>l:bc</code> corresponding to a code comment <code>(* l:bc *)</code> (i.e. a label <code>bc</code>).</p>
<p>We assume familiarity with Earley's algorithm.</p>
<h2 id="an-earley-like-algorithm">An Earley-like algorithm</h2>
<p>Earley's algorithm works with items of the form <code>X -&gt; as.bs,i,k</code> where:</p>
<ul>
<li><code>X</code> is a nonterminal (nt)</li>
<li><code>as</code> and <code>bs</code> are sequences of symbols</li>
<li><code>i</code> and <code>k</code> are indexes into the input; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cle%20k" alt="i \le k" title="i \le k" /></li>
</ul>
<p>Notation: <code>i,j,k</code> are typically integer indexes where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cle%20k%20%5Cle%20j" alt="i \le k \le j" title="i \le k \le j" />; <code>as</code> and <code>bs</code> are typically sequences of symbols; <code>X,Y,Z,nt</code> are nonterminals; <code>S,sym</code> are symbols, <code>T,tm</code> are terminals. <code>X -&gt; i as k bs</code> is an alternative notation to the usual <code>X -&gt; as.bs,i,k</code>. Similarly <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X%20%5Crightarrow%20_i%7B%7D%5Calpha_k%7B%7D%5Cbeta" alt="X \rightarrow _i{}\alpha_k{}\beta" title="X \rightarrow _i{}\alpha_k{}\beta" />. Sometimes we use spaces instead of commas in items.</p>
<p>At (l:bc) the type of <code>nt_item</code> (nonterminal item) is given, which is as expected. N.B. the <code>as</code> are stored in &quot;reverse&quot; order, that is, an item <code>X -&gt; A B C. U V W,i,k</code> is stored as <code>(X,[C,B,A],[U,V,W],i,k)</code>. At (l:ba) the type of <code>tm_item</code> is given. This is not standard. A terminal item is of the form <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=_k%7B%7DT_%3F" alt="_k{}T_?" title="_k{}T_?" /> and corresponds to an attempt to start parsing the terminal <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> from index <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> (the second subscript is &quot;to be found&quot;). In traditional Earley, the input is a sequence of characters, and each terminal corresponds to a character. Here, we wish to generalize this; a terminal may correspond to a range of the input. This enables us to use existing parsers as terminal parsers, which is essential for composing parsers.</p>
<p>At (l:cd) we introduce the notion of a complete item of the form <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=_k%7B%7DS_j" alt="_k{}S_j" title="_k{}S_j" />. These items arise from items of the form <code>X -&gt; as.,k,j</code> which gives a complete item <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=_k%7B%7DX_j" alt="_k{}X_j" title="_k{}X_j" /> and parsed terminal items of the form <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=_k%7B%7DT_j" alt="_k{}T_j" title="_k{}T_j" />.</p>
<p>Notation: <code>k S j</code> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=_k%7B%7DS_j" alt="_k{}S_j" title="_k{}S_j" /></p>
<p>At (l:de) we make the string type abstract. A substring is of the form <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28s%2Ci%2Cj%29" alt="(s,i,j)" title="(s,i,j)" /> representing the part of the string <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s" alt="s" title="s" /> between <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j" alt="j" title="j" /> where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cle%20j" alt="i \le j" title="i \le j" />.</p>
<p>At (l:ef) we encode a grammar as two functions. The first provides the nt items for a given nt, with input string and index into the string. The second encodes terminal parsers: given a tm, and a substring <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28s%2Ci%2Cj%29" alt="(s,i,j)" title="(s,i,j)" />, return the indexes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> such that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28s%2Ci%2Ck%29" alt="(s,i,k)" title="(s,i,k)" /> could be parsed as tm.</p>
<p>At (l:fg) we define key types for the blocked and complete maps (more later). Both consist of an index and a symbol.</p>
<p>At (l:gh) we define the map types that we need. From a set of complete items, we need to identify those for a given start index and symbol. This is the role of the complete map type <code>cm_t</code>. The codomain of the map is a set of integers <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j" alt="j" title="j" />. If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j%20%5Cin%20cm%28k%2CS%29" alt="j \in cm(k,S)" title="j \in cm(k,S)" /> then there is a complete item <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=_k%7B%7DS_j" alt="_k{}S_j" title="_k{}S_j" />.</p>
<p>The blocked map allows us to identify, from a set of nt items, those that are currently blocked at position <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> waiting for a parse of symbol <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> to complete. <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=nitm%20%5Cin%20bm%28k%2CS%29" alt="nitm \in bm(k,S)" title="nitm \in bm(k,S)" /> if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=nitm" alt="nitm" title="nitm" /> is of the form <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X%20%5Crightarrow%20i%2C%5Calpha%2Ck%2C%28S%20%5Cbeta%29" alt="X \rightarrow i,\alpha,k,(S \beta)" title="X \rightarrow i,\alpha,k,(S \beta)" />.</p>
<p>The state of the Earley algorithm is represented as a record with the following fields:</p>
<ul>
<li><code>todo_done</code> is the set of all items that are pending, or have already been processed</li>
<li><code>todo</code> is the list of all items that are pending</li>
<li><code>blocked</code> is the blocked map</li>
<li><code>complete</code> is the complete map</li>
</ul>
<p>At (l:hi) we add an item to the state by adding it to <code>todo</code> and <code>todo_done</code>. If the item is already in <code>todo_done</code> we leave the state unchanged.</p>
<p>At (l:ij) we implement the core Earley step. This takes a blocked item <code>X -&gt; i,as,k,(S bs)</code> and a complete item <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=_k%7B%7DS_j" alt="_k{}S_j" title="_k{}S_j" /> and forms a new item of the form <code>X -&gt; i,(as S),j,bs</code>. Note that the <code>as</code> field is stored in &quot;reverse&quot; order (to make this operation more efficient).</p>
<p>Notation: <code>(S bs)</code> is the list <code>bs</code> with <code>S</code> cons'ed on. <code>(as S)</code> is the list <code>as</code> with <code>S</code> joined on the end.</p>
<pre><code>X -&gt; i,as,k,(S bs)   k S j
------------------------- cut
X -&gt; i,(as S),j,bs</code></pre>
<p>We then give definitions for adding a complete item to the complete map, and a blocked item to the blocked map.</p>
<p>At (l:ja) we pull out some common code to process a list of complete items, all of which have a given key. Processing involves adding each <code>citm</code> to the complete map, and cutting each item against the relevant blocked items.</p>
<p>At (l:jk) we reach the core <code>step</code> part of Earley's algorithm. The full algorithm repeatedly applies <code>step</code> to an initial state until there are no further <code>todo</code> items.</p>
<p>At (l:jp) we at processing an nt item. This item may be complete. If so, via <code>process_citms</code> we record it in the complete map, and process it against any blocked items with the same key.</p>
<p>At (l:kl) the nt item is not complete. So we record it in the blocked map. We then try to progress the item by cutting it with all the current complete items with the same key. It may be that we have yet to process all or any of the relevant complete items. So we also have to look at the symbol the nt item is blocked on, and manufacture more items. This is (l:lm).</p>
<p>At (l:mn) we are processing a terminal item. We use <code>p_of_tm</code> to determine which substrings of the input can be parsed as the terminal <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" />. This gives us complete items of the form <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=_k%7B%7DT_j" alt="_k{}T_j" title="_k{}T_j" />. For each <code>citm</code> we then update the complete map and process against blocked items, using <code>process_citms</code></p>
<p>That concludes the explanation of the core of the algorithm.</p>
<p>At (l:no) we repeatedly apply the step function in a loop until there are no more items to do.</p>
<p>At (l:op) we apply the loop function to an initial state.</p>
<p>At (l:pq) we give an example for the grammar <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E%20%5Crightarrow%20E%20E%20E%20%7C%20%271%27%20%7C%20%5Cepsilon" alt="E \rightarrow E E E | &#39;1&#39; | \epsilon" title="E \rightarrow E E E | &#39;1&#39; | \epsilon" />.</p>
<h2 id="complexity">Complexity</h2>
<p>We assume that there is a constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" /> such that each invocation of <code>p_of_tm</code> produces at most <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%20%2A%20n" alt="c * n" title="c * n" /> results.</p>
<p>As implemented, the algorithm is <code>O(n^3 log n)</code> because the sets and maps use OCaml's default sets and maps, which are implemented as binary trees. However, clearly given an input and a grammar, there are only a finite number of items that can be in any of the sets or maps. Thus, we can enumerate these items, and use the enumeration to implement e.g. a set as an array. This would give the <code>O(n^3)</code> desired complexity.</p>
</body>
</html>
