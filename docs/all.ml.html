<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>tmp.ml</title>
<meta name="generator" content="emacs 26.1; htmlfontify 0.21" />
<style type="text/css"><!-- 
body { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #232627;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.default   { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #232627;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.default a { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #232627;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.infix-extension-node   { color: #483d8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.infix-extension-node a { color: #483d8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.string   { color: #8b2252;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.string a { color: #8b2252;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.label   { color: #008b8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.label a { color: #008b8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.doc   { color: #8b2252;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.doc a { color: #8b2252;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.comment   { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.comment a { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.comment-delimiter   { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.comment-delimiter a { color: #b22222;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.constant   { color: #008b8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.constant a { color: #008b8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.builtin   { color: #483d8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.builtin a { color: #483d8b;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.constructor   { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #232627;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.constructor a { font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  color: #232627;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.keyword   { color: #a020f0;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.keyword a { color: #a020f0;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.type   { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.type a { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.variable-name   { color: #a0522d;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.variable-name a { color: #a0522d;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.function-name   { color: #0000ff;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.function-name a { color: #0000ff;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.operator   { color: #a52a2a;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.operator a { color: #a52a2a;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.module   { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.module a { color: #228b22;  font-family: Ubuntu Mono;  font-stretch: normal;  font-weight: 500;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
span.governing   { color: #000000;  font-weight: 700;  font-family: Ubuntu Mono;  font-stretch: normal;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: none; }
span.governing a { color: #000000;  font-weight: 700;  font-family: Ubuntu Mono;  font-stretch: normal;  font-style: normal;  background: #fcfcfc;  font-size: 10pt;  text-decoration: underline; }
 --></style>

    <script type="text/javascript"><!--
  // this function is needed to work around
  // a bug in IE related to element attributes
  function hasClass(obj)
  {
      var result = false;
      if (obj.getAttributeNode("class") != null)
      {
          result = obj.getAttributeNode("class").value;
      }
      return result;
  }

  function stripe(id)
  {
      // the flag we'll use to keep track of
      // whether the current row is odd or even
      var even = false;

      // if arguments are provided to specify the colors
      // of the even & odd rows, then use them;
      // otherwise use the following defaults:
      var evenColor = arguments[1] ? arguments[1] : "#fff";
      var oddColor  = arguments[2] ? arguments[2] : "#ddd";

      // obtain a reference to the desired table
      // if no such table exists, abort
      var table = document.getElementById(id);
      if (! table) { return; }

      // by definition, tables can have more than one tbody
      // element, so we'll have to get the list of child
      // &lt;tbody&gt;s
      var tbodies = table.getElementsByTagName("tbody");

      // and iterate through them...
      for (var h = 0; h < tbodies.length; h++)
      {
          // find all the &lt;tr&gt; elements...
          var trs = tbodies[h].getElementsByTagName("tr");

          // ... and iterate through them
          for (var i = 0; i < trs.length; i++)
          {
              // avoid rows that have a class attribute
              // or backgroundColor style
              if (! hasClass(trs[i]) &&
                  ! trs[i].style.backgroundColor)
              {
                  // get all the cells in this row...
                  var tds = trs[i].getElementsByTagName("td");

                  // and iterate through them...
                  for (var j = 0; j < tds.length; j++)
                  {
                      var mytd = tds[j];

                      // avoid cells that have a class attribute
                      // or backgroundColor style
                      if (! hasClass(mytd) &&
                          ! mytd.style.backgroundColor)
                      {
                          mytd.style.backgroundColor =
                            even ? evenColor : oddColor;
                      }
                  }
              }
              // flip from odd to even, or vice-versa
              even =  ! even;
          }
      }
  }

  function toggle_invis( name )
  {
      var filter =
        { acceptNode:
          function( node )
          { var classname = node.id;
            if( classname )
            { var classbase = classname.substr( 0, name.length );
              if( classbase == name ) { return NodeFilter.FILTER_ACCEPT; } }
            return NodeFilter.FILTER_SKIP; } };
      var walker = document.createTreeWalker( document.body           ,
                                              NodeFilter.SHOW_ELEMENT ,
                                              filter                  ,
                                              false                   );
      while( walker.nextNode() )
      {
          var e = walker.currentNode;
          if( e.style.display == "none" ) { e.style.display = "inline"; }
          else                            { e.style.display = "none";   }
      }
  }
--> </script>
  </head>
  <body onload="stripe('index'); return true;">

<pre><span class="governing">module</span> <span class="module">Log</span> <span class="operator">=</span> <span class="governing">struct</span> 
    <span class="governing">let</span> <span class="function-name">log</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">x</span><span class="operator">:</span><span class="type">unit </span><span class="module">Lazy.</span><span class="type">t</span><span class="operator">)</span> <span class="operator">=</span> <span class="module">Lazy.</span>force x
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Misc</span> <span class="operator">=</span> <span class="governing">struct</span> 
    <span class="governing">let</span> <span class="function-name">iter_opt</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">f</span><span class="operator">:</span><span class="type">'a </span><span class="operator">-&gt;</span><span class="type"> 'a option</span><span class="operator">)</span> <span class="operator">=</span> 
      <span class="governing">let</span> <span class="governing">rec</span> <span class="function-name">loop</span><span class="variable-name"> x</span> <span class="operator">=</span> 
        <span class="keyword">match</span> f x <span class="keyword">with</span>
        <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> x
        <span class="operator">|</span> <span class="constructor">Some</span> x <span class="operator">-&gt;</span> loop x
      <span class="governing">in</span>
      <span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> loop x
    
    
    <span class="governing">let</span> <span class="function-name">rev_filter_map</span><span class="variable-name"> f xs</span> <span class="operator">=</span>
      <span class="operator">([],</span>xs<span class="operator">)</span> <span class="operator">|&gt;</span> iter_opt <span class="operator">(</span><span class="keyword">function</span>
          <span class="operator">|</span> _<span class="operator">,[]</span> <span class="operator">-&gt;</span> <span class="constructor">None</span>
          <span class="operator">|</span> xs'<span class="operator">,</span>x<span class="operator">::</span>xs <span class="operator">-&gt;</span> 
            f x <span class="operator">|&gt;</span> <span class="keyword">function</span>
            <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="constructor">Some</span><span class="operator">(</span>xs'<span class="operator">,</span>xs<span class="operator">)</span>
            <span class="operator">|</span> <span class="constructor">Some</span> y <span class="operator">-&gt;</span> <span class="constructor">Some</span><span class="operator">(</span>y<span class="operator">::</span>xs'<span class="operator">,</span>xs<span class="operator">))</span>
      <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">xs'</span><span class="operator">,[])</span> <span class="operator">-&gt;</span> xs'
    
    <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> rev_filter_map
    
    
    <span class="governing">let</span> <span class="function-name">string_matches_at</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">string </span><span class="operator">~</span><span class="variable-name">sub </span><span class="operator">~</span><span class="variable-name">pos</span> <span class="operator">=</span>
      <span class="governing">let</span> <span class="variable-name">len</span> <span class="operator">=</span> <span class="module">String.</span>length sub <span class="governing">in</span>
      <span class="keyword">try</span>
        <span class="module">String.</span>sub string pos len <span class="operator">=</span> sub 
      <span class="keyword">with</span> <span class="builtin">Invalid_argument</span> _ <span class="operator">-&gt;</span> <span class="constant">false</span>
    
    
    
    <span class="comment-delimiter">(* </span><span class="comment">iterate over a list until the first Some x; return this (or None if no such elt </span><span class="comment-delimiter">*)</span>
    <span class="governing">let</span> <span class="function-name">iter_till_some</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">f</span><span class="operator">:</span><span class="type"> 'a </span><span class="operator">-&gt;</span><span class="type"> 'b option</span><span class="operator">)</span><span class="variable-name"> xs</span> <span class="operator">=</span>
      <span class="operator">(</span><span class="constructor">None</span><span class="operator">,</span>xs<span class="operator">)</span> <span class="operator">|&gt;</span> iter_opt <span class="operator">(</span><span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">ret</span><span class="operator">,</span><span class="variable-name">xs</span><span class="operator">)</span> <span class="operator">-&gt;</span>
          <span class="keyword">match</span> ret <span class="keyword">with</span> 
          <span class="operator">|</span> <span class="constructor">Some</span> x <span class="operator">-&gt;</span> <span class="constructor">None</span>
          <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
              <span class="keyword">match</span> xs <span class="keyword">with</span> 
              <span class="operator">|</span> <span class="operator">[]</span> <span class="operator">-&gt;</span> <span class="constructor">None</span>
              <span class="operator">|</span> x<span class="operator">::</span>xs <span class="operator">-&gt;</span> 
                f x <span class="operator">|&gt;</span> <span class="keyword">function</span>
                <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="constructor">Some</span> <span class="operator">(</span><span class="constructor">None</span><span class="operator">,</span>xs<span class="operator">)</span>
                <span class="operator">|</span> <span class="constructor">Some</span> ret <span class="operator">-&gt;</span> <span class="constructor">Some</span><span class="operator">(</span><span class="constructor">Some</span> ret<span class="operator">,[])))</span>
      <span class="operator">|&gt;</span> <span class="keyword">function</span> <span class="operator">(</span>ret<span class="operator">,</span>_<span class="operator">)</span> <span class="operator">-&gt;</span> ret
    
    <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">:</span> <span class="operator">(</span><span class="type">'a </span><span class="operator">-&gt;</span><span class="type"> 'b option</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> 'a list </span><span class="operator">-&gt;</span><span class="type"> 'b option </span><span class="operator">=</span> iter_till_some
    
    
    <span class="governing">module</span> <span class="module">Int_set</span> <span class="operator">=</span> <span class="module">Set.Make</span><span class="operator">(</span>
      <span class="governing">struct</span> <span class="governing">type</span> <span class="type">t</span> <span class="operator">=</span> int <span class="governing">let</span> <span class="variable-name">compare</span><span class="operator">:</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">=</span><span class="type"> </span><span class="module">Pervasives.</span><span class="type">compare </span><span class="governing">end</span><span class="operator">)</span>
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Prelude</span> <span class="operator">=</span> <span class="governing">struct</span> 
    
    <span class="doc">(** {2 Some profiling parameters, set later in bin/} *)</span>
    
    <span class="comment-delimiter">(* </span><span class="comment">let _ = Log.log @@ lazy (Printf.printf &quot;%s: various mark_ref globals\n%!&quot; __FILE__) </span><span class="comment-delimiter">*)</span>
    
    <span class="governing">let</span> <span class="variable-name">base_mark_ref</span> <span class="operator">:</span> <span class="operator">(</span><span class="type">string </span><span class="operator">-&gt;</span><span class="type"> unit</span><span class="operator">)</span><span class="type"> </span><span class="builtin">ref</span><span class="type"> </span><span class="operator">=</span> <span class="builtin">ref</span> <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span> <span class="operator">())</span>
    
    <span class="governing">let</span> <span class="variable-name">spec_mark_ref</span> <span class="operator">:</span> <span class="operator">(</span><span class="type">string </span><span class="operator">-&gt;</span><span class="type"> unit</span><span class="operator">)</span><span class="type"> </span><span class="builtin">ref</span><span class="type"> </span><span class="operator">=</span> <span class="builtin">ref</span> <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span> <span class="operator">())</span>
    
    <span class="governing">let</span> <span class="variable-name">unstaged_mark_ref</span> <span class="operator">:</span> <span class="operator">(</span><span class="type">string </span><span class="operator">-&gt;</span><span class="type"> unit</span><span class="operator">)</span><span class="type"> </span><span class="builtin">ref</span><span class="type"> </span><span class="operator">=</span> <span class="builtin">ref</span> <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span> <span class="operator">())</span>
    
    
    <span class="doc">(** {2 Type for inputs} *)</span>
    
    <span class="governing">type</span> <span class="type">'a input</span> <span class="operator">=</span> <span class="operator">{</span>
      input<span class="operator">:</span>'a<span class="operator">;</span>
      input_length<span class="operator">:</span> int
    <span class="operator">}</span>
    
    
    <span class="doc">(** {2 Type for grammars} *)</span>
    
    <span class="doc">(** In the interface to Earley, the user has to know the structure of
       the sym type; so it is useful to have this known outside *)</span>
    <span class="governing">type</span> <span class="operator">(</span><span class="type">'nt</span><span class="operator">,</span><span class="type">'tm</span><span class="operator">)</span><span class="type"> generic_sym</span> <span class="operator">=</span> <span class="constructor">Nt</span> <span class="keyword">of</span> 'nt <span class="operator">|</span> <span class="constructor">Tm</span> <span class="keyword">of</span> 'tm
    
    <span class="doc">(** A simple representation of a grammar. We might want to generalize this. *)</span>
    <span class="governing">type</span> <span class="operator">(</span><span class="type">'nt</span><span class="operator">,</span><span class="type">'tm</span><span class="operator">)</span><span class="type"> simple_grammar</span> <span class="operator">=</span> <span class="operator">{</span>
      nt_to_rhss<span class="operator">:</span> 'nt <span class="operator">-&gt;</span> <span class="operator">(</span>'nt<span class="operator">,</span>'tm<span class="operator">)</span> generic_sym list list
    <span class="operator">}</span>
    
    <span class="governing">type</span> <span class="operator">(</span><span class="type">'nt</span><span class="operator">,</span><span class="type">'tm</span><span class="operator">,</span><span class="type">'a</span><span class="operator">)</span><span class="type"> input_dependent_grammar</span> <span class="operator">=</span> <span class="operator">{</span>
      nt_input_to_rhss<span class="operator">:</span> <span class="label">nt</span><span class="operator">:</span>'nt <span class="operator">-&gt;</span> <span class="label">input</span><span class="operator">:</span>'a input <span class="operator">-&gt;</span> <span class="label">pos</span><span class="operator">:</span>int <span class="operator">-&gt;</span> <span class="operator">(</span>'nt<span class="operator">,</span>'tm<span class="operator">)</span>generic_sym list list
    <span class="operator">}</span>
    
    <span class="governing">let</span> <span class="function-name">simple_to_input_dependent_grammar</span> <span class="operator">{</span> nt_to_rhss <span class="operator">}</span> <span class="operator">=</span> <span class="operator">{</span>
      nt_input_to_rhss<span class="operator">=</span><span class="keyword">fun</span> <span class="operator">~</span><span class="variable-name">nt </span><span class="operator">~</span><span class="variable-name">input </span><span class="operator">~</span><span class="variable-name">pos</span> <span class="operator">-&gt;</span>
        nt_to_rhss nt <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">syms_list</span> <span class="operator">-&gt;</span> syms_list
    <span class="operator">}</span>
    
    
    <span class="doc">(** {2 Types for terminal parsers} *)</span>
    
    <span class="governing">type</span> <span class="operator">(</span><span class="type">'tm</span><span class="operator">,</span><span class="type">'a</span><span class="operator">)</span><span class="type"> terminal_input_matcher</span> <span class="operator">=</span> <span class="operator">{</span>
      parse_tm<span class="operator">:</span> <span class="label">tm</span><span class="operator">:</span>'tm <span class="operator">-&gt;</span> <span class="label">input</span><span class="operator">:</span>'a input <span class="operator">-&gt;</span> <span class="label">pos</span><span class="operator">:</span>int <span class="operator">-&gt;</span> int list
    <span class="operator">}</span>
    
    <span class="comment-delimiter">(*</span><span class="comment">
    (** Provided by user; NOTE that this exposes the [nt_item] type, but
       we could instead go for a list of sym. Then we might also just
       require a map from nt to rhs list *)
    type ('nt,'tm,'nt_item,'input) grammar_etc = {
      new_items: nt:'nt -&gt; input:'input -&gt; pos:int -&gt; 'nt_item list;
      parse_tm: tm:'tm -&gt; input:'input -&gt; pos:int -&gt; input_length:int -&gt; int list;
      input:'input;
      input_length:int;
    }
    </span><span class="comment-delimiter">*)</span>
    
    
    <span class="doc">(** {2 Parsing result type} *)</span>
    
    <span class="doc">(** Result of parse; complete items is something like (i,sym) -&gt; j set *)</span>
    <span class="governing">type</span> <span class="operator">(</span><span class="type">'b</span><span class="operator">,</span><span class="type">'c</span><span class="operator">,</span><span class="type">'d</span><span class="operator">)</span><span class="type"> parse_result</span> <span class="operator">=</span> <span class="operator">{</span>
      count<span class="operator">:</span> int<span class="operator">;</span>
      items<span class="operator">:</span>'b<span class="operator">;</span>
      complete_items<span class="operator">:</span>'c<span class="operator">;</span>
      debug<span class="operator">:</span> 'd<span class="operator">;</span>
    <span class="operator">}</span>
    
    
    
    <span class="doc">(** {2 Common required interface} *)</span>
    
    <span class="doc">(** We often parameterize over nt,tm *)</span>
    <span class="governing">module</span> <span class="governing">type</span> <span class="module">NT_TM</span> <span class="operator">=</span> <span class="governing">sig</span>  <span class="governing">type</span> <span class="type">nt</span> <span class="governing">type</span> <span class="type">tm</span> <span class="governing">end</span>
    
    <span class="doc">(** What is often required by the [Make] functor *)</span> 
    <span class="governing">module</span> <span class="governing">type</span> <span class="module">REQUIRED</span> <span class="operator">=</span> <span class="governing">sig</span>
    
      <span class="governing">type</span> <span class="type">nt</span>
      <span class="governing">type</span> <span class="type">tm</span>
      <span class="governing">type</span> <span class="type">sym</span>
    
      <span class="governing">val</span> <span class="function-name">is_nt</span><span class="operator">:</span> sym <span class="operator">-&gt;</span> bool
      <span class="governing">val</span> <span class="function-name">dest_nt</span><span class="operator">:</span> sym <span class="operator">-&gt;</span> nt
      <span class="governing">val</span> <span class="function-name">dest_tm</span><span class="operator">:</span> sym <span class="operator">-&gt;</span> tm
      <span class="governing">val</span> <span class="function-name">_NT</span><span class="operator">:</span> nt <span class="operator">-&gt;</span> sym
      <span class="governing">val</span> <span class="function-name">_TM</span><span class="operator">:</span> tm <span class="operator">-&gt;</span> sym
    
      <span class="governing">type</span> <span class="type">sym_list</span>
      <span class="governing">val</span> <span class="function-name">syms_nil</span><span class="operator">:</span> sym_list <span class="operator">-&gt;</span> bool
      <span class="governing">val</span> <span class="function-name">syms_hd</span><span class="operator">:</span> sym_list <span class="operator">-&gt;</span> sym
      <span class="governing">val</span> <span class="function-name">syms_tl</span><span class="operator">:</span> sym_list <span class="operator">-&gt;</span> sym_list
    
      <span class="governing">type</span> <span class="type">nt_item</span>  
      <span class="governing">val</span> <span class="function-name">dot_nt</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> nt
      <span class="governing">val</span> <span class="function-name">dot_i</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> int
      <span class="governing">val</span> <span class="function-name">dot_k</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> int
      <span class="governing">val</span> <span class="function-name">dot_bs</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> sym_list
    
      <span class="governing">val</span> <span class="function-name">cut</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> int <span class="operator">-&gt;</span> nt_item
    
      <span class="comment-delimiter">(* </span><span class="comment">type 'input grammar_etc' = (nt,tm,nt_item,'input) grammar_etc </span><span class="comment-delimiter">*)</span>
    <span class="governing">end</span>  <span class="comment-delimiter">(* </span><span class="comment">REQUIRED </span><span class="comment-delimiter">*)</span>
    
    <span class="doc">(** Simple instantiation of basic types *)</span>
    <span class="governing">module</span> <span class="module">Simple_items</span><span class="operator">(</span><span class="constructor">A</span><span class="operator">:</span><span class="governing">sig</span> <span class="governing">type</span> <span class="type">nt</span> <span class="governing">type</span> <span class="type">tm</span> <span class="governing">end</span><span class="operator">)</span> <span class="operator">=</span> <span class="governing">struct</span>
      <span class="governing">open </span><span class="module">A</span>
    
      <span class="governing">type</span> <span class="type">sym</span> <span class="operator">=</span> <span class="operator">(</span>nt<span class="operator">,</span>tm<span class="operator">)</span>generic_sym
      <span class="governing">let</span> <span class="function-name">is_nt</span> <span class="operator">=</span> <span class="keyword">function</span> <span class="constructor">Nt</span> x <span class="operator">-&gt;</span> <span class="constant">true</span> <span class="operator">|</span> <span class="constructor">Tm</span> x <span class="operator">-&gt;</span> <span class="constant">false</span>
      <span class="governing">let</span> <span class="function-name">dest_nt</span> <span class="operator">=</span> <span class="keyword">function</span> <span class="constructor">Nt</span> x <span class="operator">-&gt;</span> x <span class="operator">|</span> _ <span class="operator">-&gt;</span> <span class="builtin">failwith</span> <span class="string">&quot;dest_nt&quot;</span>
      <span class="governing">let</span> <span class="function-name">dest_tm</span> <span class="operator">=</span> <span class="keyword">function</span> <span class="constructor">Tm</span> x <span class="operator">-&gt;</span> x <span class="operator">|</span> _ <span class="operator">-&gt;</span> <span class="builtin">failwith</span> <span class="string">&quot;dest_tm&quot;</span>
      <span class="governing">let</span> <span class="function-name">_NT</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">x</span><span class="operator">:</span><span class="type">nt</span><span class="operator">)</span> <span class="operator">=</span> <span class="constructor">Nt</span> x
      <span class="governing">let</span> <span class="function-name">_TM</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">x</span><span class="operator">:</span><span class="type">tm</span><span class="operator">)</span> <span class="operator">=</span> <span class="constructor">Tm</span> x
    
      <span class="governing">let</span> <span class="function-name">sym_case</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">nt </span><span class="operator">~</span><span class="variable-name">tm</span> <span class="operator">=</span> <span class="keyword">function</span>
        <span class="operator">|</span> <span class="constructor">Nt</span> x <span class="operator">-&gt;</span> nt x
        <span class="operator">|</span> <span class="constructor">Tm</span> y <span class="operator">-&gt;</span> tm y
    
      <span class="governing">type</span> <span class="type">sym_list</span> <span class="operator">=</span> sym list
      <span class="governing">let</span> <span class="function-name">syms_nil</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">xs</span><span class="operator">:</span><span class="type">sym_list</span><span class="operator">)</span> <span class="operator">=</span> <span class="keyword">match</span> xs <span class="keyword">with</span> <span class="operator">[]</span> <span class="operator">-&gt;</span> <span class="constant">true</span> <span class="operator">|</span> _ <span class="operator">-&gt;</span> <span class="constant">false</span>
      <span class="governing">let</span> <span class="function-name">syms_hd</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">xs</span><span class="operator">:</span><span class="type">sym_list</span><span class="operator">)</span> <span class="operator">=</span> <span class="module">List.</span>hd xs
      <span class="governing">let</span> <span class="function-name">syms_tl</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">xs</span><span class="operator">:</span><span class="type">sym_list</span><span class="operator">)</span> <span class="operator">=</span> <span class="module">List.</span>tl xs
    
      <span class="governing">type</span> <span class="type">nt_item</span> <span class="operator">=</span> <span class="operator">{</span> nt<span class="operator">:</span>nt<span class="operator">;</span> i_<span class="operator">:</span>int<span class="operator">;</span> k_<span class="operator">:</span>int<span class="operator">;</span> bs<span class="operator">:</span>sym_list <span class="operator">}</span>
      <span class="governing">let</span> <span class="function-name">dot_nt</span><span class="variable-name"> x</span> <span class="operator">=</span> x.nt
      <span class="governing">let</span> <span class="function-name">dot_i</span><span class="variable-name"> x</span> <span class="operator">=</span> x.i_
      <span class="governing">let</span> <span class="function-name">dot_k</span><span class="variable-name"> x</span> <span class="operator">=</span> x.k_
      <span class="governing">let</span> <span class="function-name">dot_bs</span><span class="variable-name"> x</span> <span class="operator">=</span> x.bs
      <span class="governing">let</span> <span class="function-name">mk_nt_item</span><span class="variable-name"> nt i bs</span> <span class="operator">=</span> <span class="operator">{</span> nt<span class="operator">;</span> i_<span class="operator">=</span>i<span class="operator">;</span> k_<span class="operator">=</span>i<span class="operator">;</span> bs <span class="operator">}</span>
    
      <span class="governing">let</span> <span class="function-name">cut</span><span class="variable-name"> itm j</span> <span class="operator">=</span> <span class="operator">{</span>itm <span class="keyword">with</span> k_<span class="operator">=</span>j<span class="operator">;</span> bs<span class="operator">=</span><span class="module">List.</span>tl itm.bs<span class="operator">}</span>
    
      <span class="comment-delimiter">(* </span><span class="comment">type sym_item = { i_:int; sym:sym; j_:int } </span><span class="comment-delimiter">*)</span>
      <span class="comment-delimiter">(* </span><span class="comment">type sym_at_k = { sym:sym; k_:int }  </span><span class="comment-delimiter">*)</span>
    <span class="governing">end</span>
    
    
    
    <span class="comment-delimiter">(*</span><span class="comment">
    (** Generic type of items (for spec?) *)
    type ('a,'b,'c) generic_item = 
      | Nt_item of 'a
      | Sym_item of 'b
      | Sym_at_k of 'c
    </span><span class="comment-delimiter">*)</span>
    
    <span class="comment-delimiter">(*</span><span class="comment">
      let filter_sort_items itms = 
        itms
        |&gt; Misc.rev_filter_map (function
            | Nt_item x -&gt; Some x
            | _ -&gt; None)
        |&gt; List.sort (fun itm1 itm2 -&gt; 
            let f {nt;i_;k_;bs} = nt,i_,k_,List.length bs,bs in
            Pervasives.compare (f itm1) (f itm2))
    </span><span class="comment-delimiter">*)</span>
    
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Wip</span> <span class="operator">=</span> <span class="governing">struct</span> 
    <span class="comment-delimiter">(*</span><span class="comment">
    (** A simple specification of general parsing (not only Earley). For
       the implementation, see {!Earley_unstaged}. *)
    
    open Prelude
    
    module type REQUIRED = sig
      include Prelude.REQUIRED
      type sym_item = { i_:int; sym:sym; j_:int }
      type sym_at_k = { sym:sym; k_:int } 
    
      type item = 
        | Nt_item of nt_item
        | Sym_item of sym_item
        | Sym_at_k of sym_at_k
    end
    
    module Make_extra_items(A:sig type sym type nt_item end) = struct
      open A
      type sym_item = { i_:int; sym:sym; j_:int }
      type sym_at_k = { sym:sym; k_:int } 
    
      type item = 
        | Nt_item of nt_item
        | Sym_item of sym_item
        | Sym_at_k of sym_at_k
    end
    
    (** Internal implementation *)
    module Internal(S:sig include REQUIRED type state end) = struct
      open S
    
      module M = struct
        type 'a m = state -&gt; 'a * state
        let ( &gt;&gt;= ) (a:'a m) (ab:'a -&gt; 'b m) : 'b m = 
          fun s -&gt;
          a s |&gt; fun (a,s) -&gt; 
          ab a s
        let _ = ( &gt;&gt;= )
        let return a = fun s -&gt; (a,s)
      end
      open M
    
      (** Main Earley routine, parameterized *)
      let _earley 
          ~(expand_nt:nt*int-&gt;unit m) ~(expand_tm:tm*int-&gt;unit m) 
          ~incr_count
          ~(get_blocked_items:int*sym-&gt;nt_item list m)
          ~(get_complete_items:int*sym -&gt; int list m)
          ~(add_item:item -&gt; unit m)
          ~(add_items:item list -&gt; unit m)
          ~(pop_todo: unit-&gt; item option m)
          ~(note_blocked_cuts: nt_item -&gt; int list -&gt; unit m)
          ~(note_complete_cuts: nt_item list -&gt; int -&gt; unit m)
        = 
    
        let mark = !spec_mark_ref in
    
        (* process a blocked item *)
        let cut_blocked_item = fun itm -&gt; 
          let k_,_S = (itm|&gt;dot_k,itm|&gt;dot_bs|&gt;syms_hd) in
          mark &quot;am&quot;;
          get_complete_items (k_,_S) &gt;&gt;= fun js -&gt;
          mark &quot;ap&quot;;
          note_blocked_cuts itm js &gt;&gt;= fun () -&gt;
          js |&gt; List.map (fun j -&gt; Nt_item (cut itm j))
          |&gt; add_items &gt;&gt;= fun _ -&gt;
          mark &quot;as&quot;;
          return ()              
        in
    
        (* process a complete item *)
        let cut_complete_item =
          fun {i_;sym;j_} -&gt; 
            mark &quot;bm&quot;;
            get_blocked_items (i_,sym) &gt;&gt;= fun itms -&gt;
            mark &quot;bp&quot;;
            note_complete_cuts itms j_ &gt;&gt;= fun () -&gt;
            itms |&gt; List.map (fun itm -&gt; Nt_item (cut itm j_))
            |&gt; add_items &gt;&gt;= fun () -&gt;
            mark &quot;bs&quot;;
            return ()
        in
    
        (* process an item *)
        let step itm =
          mark &quot;em&quot;;
          match itm with 
          | Nt_item itm -&gt; (
              incr_count() &gt;&gt;= fun () -&gt; 
              let bs = itm|&gt;dot_bs in
              match bs|&gt;syms_nil with
              | true -&gt; 
                (* item is complete *)
                let itm = Sym_item {sym=_NT (itm|&gt;dot_nt); i_=(itm|&gt;dot_i); j_=(itm|&gt;dot_k)} in
                add_item itm &gt;&gt;= fun () -&gt;
                mark &quot;ep&quot;;
                return ()
              | false -&gt; (
                  let _S,bs = syms_hd bs, syms_tl bs in
                  (* we need to record that we need to expand _S *)
                  mark &quot;er&quot;;
                  add_item (Sym_at_k { sym=_S; k_=(itm|&gt;dot_k)}) &gt;&gt;= fun () -&gt;
                  mark &quot;eu&quot;;
                  (* and we need to process the item against complete items *)
                  cut_blocked_item itm &gt;&gt;= fun _ -&gt;
                  mark &quot;ev&quot;;
                  return ()))
          | Sym_item itm -&gt; (
              cut_complete_item itm &gt;&gt;= fun _ -&gt;
              mark &quot;ga&quot;;
              return ())
          | Sym_at_k {sym;k_} -&gt; (
              match is_nt sym with
              | true -&gt; expand_nt (dest_nt sym,k_) &gt;&gt;= fun () -&gt; mark &quot;ha&quot;; return ()
              | false -&gt; expand_tm (dest_tm sym,k_) &gt;&gt;= fun () -&gt; mark &quot;hb&quot;; return ())        
        in
    
        let _ = step in
    
        (* loop until no items left to process *)
        let rec loop () = 
          pop_todo () &gt;&gt;= function
          | None -&gt; return ()
          | Some itm -&gt; step itm &gt;&gt;= fun _ -&gt; loop ()
        in
        loop ()
    
      let _ :
        expand_nt:(nt * int -&gt; unit m) -&gt;
        expand_tm:(tm * int -&gt; unit m) -&gt;
        incr_count:(unit -&gt; unit m) -&gt;
        get_blocked_items:(int * sym -&gt; nt_item list m) -&gt;
        get_complete_items:(int * sym -&gt; int list m) -&gt;
        add_item:(item -&gt; unit m) -&gt;
        add_items:(item list -&gt; unit m) -&gt;
        pop_todo:(unit -&gt; item option m) -&gt; 
        note_blocked_cuts:(nt_item -&gt; int list -&gt; unit m) -&gt;
        note_complete_cuts:(nt_item list -&gt; int -&gt; unit m) -&gt;
        unit m
        = _earley
    
      (** expand_... are in the monad; adjust the types of expand_nt and
         expand_tm so that they return a list of items and a list of ints
         *)
      let earley ~expand_nt ~expand_tm ~add_items =
        let expand_nt (nt,i) = 
          add_items (expand_nt (nt,i) |&gt; List.map (fun itm -&gt; Nt_item itm))
        in
        let expand_tm (tm,i_) =
          expand_tm (tm,i_) 
          |&gt; List.map (fun j_ -&gt; (Sym_item{i_;sym=_TM tm;j_}))
          |&gt; add_items
        in
        _earley ~expand_nt ~expand_tm ~add_items
    
      let _ : 
        expand_nt:(nt * int -&gt; nt_item list) -&gt;
        expand_tm:(tm * int -&gt; int list) -&gt;
        add_items:(item list -&gt; unit m) -&gt;
        incr_count:(unit -&gt; unit m) -&gt;
        get_blocked_items:(int * sym -&gt; nt_item list m) -&gt;
        get_complete_items:(int * sym -&gt; int list m) -&gt;
        add_item:(item -&gt; unit m) -&gt; pop_todo:(unit -&gt; item option m) -&gt; 
        note_blocked_cuts:(nt_item -&gt; int list -&gt; unit m) -&gt;
        note_complete_cuts:(nt_item list -&gt; int -&gt; unit m) -&gt;
        unit m = earley
    
    end
    
    (** Refine the state type; for the spec, we use an extremely
       inefficient state type (for which the implementation of the util
       functions are hopefully correct); see {!Earley_unstaged} for an
       efficient version *)
    module Internal_with_inefficient_spec_state(Req:REQUIRED) = struct
      open Req
    
      module State_type = struct
    
        (* todo_done is really a set; we add items to todo providing they
           are not already in todo_done *)
        type state = {
          count:int;
          mutable todo: item list;
          todo_done:(item,unit) Hashtbl.t
        }
        let empty_state = { count=0; todo=[]; todo_done=Hashtbl.create 100 }
      end
      open State_type
    
      module Internal=Internal(struct include Req include State_type end)
      open Internal
    
      (** The (executable) specification of parsing. Returns a list of
          items (FIXME?). Implementations such as Earley should return an
          identical set of items (for nt_items at least). NOTE that the
          parameters are independent of the input (in that the input is not
          present as an argument). *)
      let earley_spec ~expand_nt ~expand_tm = 
        let incr_count () s = (),{s with count=s.count+1} in
        let get_blocked_items (k,_S) s = 
          let blocked = ref [] in
          s.todo_done |&gt; Hashtbl.iter (fun itm _ -&gt;
              match itm with 
              | Nt_item itm -&gt; (
                let k_,bs = itm|&gt;dot_k,itm|&gt;dot_bs in
                match k_=k &amp;&amp; not (syms_nil bs) &amp;&amp; (syms_hd bs=_S) with
                | true -&gt; (blocked:=itm::!blocked)
                | false -&gt; ())
              | _ -&gt; ());
          !blocked,s
        in
        let get_complete_items (k,_S) s = 
          let complete = ref [] in
          s.todo_done |&gt; Hashtbl.iter (fun itm _ -&gt;
              match itm with 
              | Sym_item {i_;sym;j_} when (i_=k &amp;&amp; sym=_S) -&gt; (
                  complete:=j_::!complete)
              | _ -&gt; ());
          !complete,s
        in
        let _add_item itm s =
          match Hashtbl.mem s.todo_done itm with
          | true -&gt; ()
          | false -&gt; 
            Hashtbl.add s.todo_done itm ();
            s.todo&lt;-itm::s.todo;        
            ()
        in
        let add_items itms s = 
          itms |&gt; List.iter (fun itm -&gt; _add_item itm s);
          (),s
        in
        let add_item itm s = 
          _add_item itm s;
          (),s        
        in
        let pop_todo () s = match s.todo with
          | [] -&gt; None,s
          | x::todo -&gt; Some x,{s with todo}
        in
        let note_blocked_cuts itm js s = (),s in
        let note_complete_cuts itms j s = (),s in
        fun ~initial_nt:(nt:Req.nt) -&gt;
          { empty_state with todo=(expand_nt (nt,0)|&gt;List.map (fun x -&gt; Nt_item x)) }
          |&gt; earley
            ~expand_nt ~expand_tm ~incr_count ~get_blocked_items ~get_complete_items
            ~add_item ~add_items ~pop_todo
            ~note_blocked_cuts ~note_complete_cuts
          |&gt; fun ((),s) -&gt; 
          let complete_items = 
            fun (i,_S) -&gt; 
              get_complete_items (i,_S) s |&gt; fun (n,_) -&gt; n
          in
          let items = lazy begin
            s.todo_done 
            |&gt; Hashtbl.to_seq_keys
            |&gt; List.of_seq
          end
          in
          { count=s.count;items;complete_items }
    
      (* This exposes the nt_item type to the user; might prefer to use rhs list *)
      let earley_spec : 
        expand_nt:(nt * int -&gt; Req.nt_item list) -&gt;
        expand_tm:(tm * int -&gt; int list) -&gt; 
        initial_nt:nt -&gt; ('b,'c) parse_result
        = earley_spec
    
    end
    
    
    
    (** An example parse function which is polymorphic over symbols; no
       functors involved. *)
    module Internal_example_parse_function = struct
      
      (** An (executable) parsing specification polymorphic over
          nonterminals and terminals *)
      let earley_spec (type nt tm) ~expand_nt ~expand_tm  =
        let module A = struct
          type nonrec nt = nt
          type nonrec tm = tm      
          include Prelude.Simple_items(struct 
              type nonrec nt = nt
              type nonrec tm = tm
            end)
          include Make_extra_items(struct
              type nonrec sym = sym
              type nonrec nt_item = nt_item
            end)
        end
        in
        let open A in
        let module B = Internal_with_inefficient_spec_state(A) in
        (* let open B in *)
        (* let sym_to_sym = function `Nt nt -&gt; Nt nt | `Tm tm -&gt; Tm tm in *)
        (* let sym_to_sym = function Nt nt -&gt; `Nt nt | Tm tm -&gt; `Tm tm in  *)
        let expand_nt (nt,i) = 
          expand_nt (nt,i) |&gt; List.map (fun bs -&gt;
              (* bs |&gt; List.map sym_to_sym |&gt; fun bs -&gt; *)
              {nt;i_=i;k_=i;bs})
        in
        fun ~initial_nt -&gt;
          let res = B.earley_spec ~expand_nt ~expand_tm ~initial_nt in
          {res with items=()}  (* can't expose general items *)
    end
    </span><span class="comment-delimiter">*)</span>
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Examples_with_actions</span> <span class="operator">=</span> <span class="governing">struct</span> 
    <span class="doc">(** Some examples, with actions *)</span>
    
    <span class="doc">(**
    
    {%html:
    
    &lt;pre&gt;
        let _EEE = 
          grammar 
            ~name:&quot;EEE&quot;
            ~descr:&quot;Very ambiguous grammar, for testing Earley&quot;
            ~initial_nt:_E
            ~rules:[
              _E --&gt;_3 (nt _E,nt _E,nt _E) (fun (x,y,z) -&gt; x+y+z);
              _E --&gt;_1 one (fun _ -&gt; 1);
              _E --&gt;_1 eps (fun _ -&gt; 0);
            ]
        in
        let aho_s = 
          grammar
            ~name:&quot;aho_s&quot;
            ~descr:&quot;Aho et al. example grammar&quot;
            ~initial_nt:_S
            ~rules:[
              _S --&gt;_3 (x,nt _S,nt _S) (fun (x,y,z) -&gt; &quot;x&quot;^y^z);
              _S --&gt;_1 eps (fun _ -&gt; &quot;&quot;)
            ]
        in
    &lt;/pre&gt;
    
    %}
    *)</span>
    
    <span class="governing">module</span> <span class="module">Internal0</span> <span class="operator">=</span> <span class="governing">struct</span>
      <span class="governing">module</span> <span class="governing">type</span> <span class="module">INTERNAL_TYPED_SYMS</span> <span class="operator">=</span> <span class="governing">sig</span>
        <span class="governing">type</span> <span class="type">'a nt</span>
        <span class="governing">type</span> <span class="type">'a sym</span>
        <span class="governing">type</span> <span class="type">'a tm</span>
        <span class="governing">val</span> <span class="function-name">_E</span> <span class="operator">:</span> int nt
        <span class="governing">val</span> <span class="function-name">_S</span> <span class="operator">:</span> string nt
        <span class="governing">val</span> <span class="function-name">a</span><span class="operator">:</span> string <span class="operator">-&gt;</span> string tm
      <span class="governing">end</span>
    
      <span class="governing">module</span> <span class="governing">type</span> <span class="module">INTERNAL_REQS</span> <span class="operator">=</span> <span class="governing">sig</span> 
        <span class="governing">include</span> <span class="module">INTERNAL_TYPED_SYMS</span>
        <span class="governing">type</span> <span class="type">'a rhs</span> 
        <span class="governing">type</span> <span class="type">rule</span> 
        <span class="governing">val</span> <span class="function-name">_1</span><span class="operator">:</span> 'a sym <span class="operator">-&gt;</span> <span class="operator">(</span>'a <span class="operator">-&gt;</span> 'b<span class="operator">)</span> <span class="operator">-&gt;</span> 'b rhs
        <span class="governing">val</span> <span class="function-name">_2</span><span class="operator">:</span> <span class="operator">(</span>'a sym <span class="operator">*</span> 'b sym<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="operator">(</span>'a <span class="operator">*</span> 'b <span class="operator">-&gt;</span> 'c<span class="operator">)</span> <span class="operator">-&gt;</span> 'c rhs
        <span class="governing">val</span> <span class="function-name">_3</span><span class="operator">:</span> <span class="operator">(</span>'a sym <span class="operator">*</span> 'b sym <span class="operator">*</span> 'c sym<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="operator">(</span>'a <span class="operator">*</span> 'b <span class="operator">*</span> 'c <span class="operator">-&gt;</span> 'd<span class="operator">)</span> <span class="operator">-&gt;</span> 'd rhs
    
        <span class="governing">val</span> <span class="operator">(</span> <span class="operator">--&gt;</span> <span class="operator">)</span> <span class="operator">:</span> 'a nt <span class="operator">-&gt;</span> 'a rhs <span class="operator">-&gt;</span> rule
        <span class="governing">val</span> <span class="function-name">nt</span> <span class="operator">:</span> 'a nt <span class="operator">-&gt;</span> 'a sym
        <span class="governing">val</span> <span class="function-name">tm</span> <span class="operator">:</span> 'a tm <span class="operator">-&gt;</span> 'a sym
    
        <span class="comment-delimiter">(* </span><span class="comment">type u_nt  (\* untyped nt *\) </span><span class="comment-delimiter">*)</span>
    
        <span class="governing">type</span> <span class="type">'a grammar</span> 
        <span class="governing">val</span> <span class="function-name">grammar</span><span class="operator">:</span> <span class="label">name</span><span class="operator">:</span>string <span class="operator">-&gt;</span> <span class="label">descr</span><span class="operator">:</span>string <span class="operator">-&gt;</span> <span class="label">initial_nt</span><span class="operator">:</span>'a nt <span class="operator">-&gt;</span>
          <span class="label">rules</span><span class="operator">:</span>rule list <span class="operator">-&gt;</span> 'a grammar
      <span class="governing">end</span>
    
      <span class="governing">module</span> <span class="governing">type</span> <span class="module">INTERNAL2_REQS</span> <span class="operator">=</span> <span class="governing">sig</span> 
        <span class="governing">type</span> <span class="type">'a nt</span> 
        <span class="governing">type</span> <span class="type">u_nt</span>
        <span class="governing">val</span> <span class="function-name">nt2u</span> <span class="operator">:</span> 'a nt <span class="operator">-&gt;</span> u_nt
        <span class="governing">type</span> <span class="type">'a sym</span> 
        <span class="governing">type</span> <span class="type">u_sym</span>
        <span class="governing">val</span> <span class="function-name">sym2u</span> <span class="operator">:</span> 'a sym <span class="operator">-&gt;</span> u_sym
        <span class="governing">type</span> <span class="type">uni_val</span> 
      <span class="governing">end</span>
    
    <span class="comment-delimiter">(*</span><span class="comment">
      module type INTERNAL2_REQS = sig 
        include INTERNAL_ABSTRACT_TYPED_SYMS
    
        val u_nt2string: u_nt -&gt; string
        val u_sym2string: u_sym -&gt; string
      end
    </span><span class="comment-delimiter">*)</span>
    
    <span class="governing">end</span>
    
    <span class="governing">open </span><span class="module">Internal0</span>
    
    <span class="doc">(** Internal: grammmars defined abstractly *)</span>
    <span class="governing">module</span> <span class="module">Internal</span><span class="operator">(</span><span class="variable-name">A</span><span class="operator">:</span><span class="type">INTERNAL_REQS</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">=</span> <span class="governing">struct</span>
    
      <span class="governing">open </span><span class="module">A</span>
    
      <span class="governing">let</span> <span class="variable-name">example_grammars</span> <span class="operator">=</span>
        <span class="governing">let</span> <span class="operator">[</span>one<span class="operator">;</span>eps<span class="operator">;</span>x<span class="operator">]</span> <span class="operator">:</span> string sym list <span class="operator">=</span> <span class="module">List.</span>map a <span class="operator">[</span><span class="string">&quot;1&quot;</span><span class="operator">;</span><span class="string">&quot;&quot;</span><span class="operator">;</span><span class="string">&quot;x&quot;</span><span class="operator">]</span> <span class="operator">|&gt;</span> <span class="module">List.</span>map tm <span class="governing">in</span>
        <span class="governing">let</span> <span class="variable-name">_EEE</span> <span class="operator">=</span> 
          grammar 
            <span class="label">~name</span><span class="operator">:</span><span class="string">&quot;EEE&quot;</span>
            <span class="label">~descr</span><span class="operator">:</span><span class="string">&quot;Very ambiguous grammar, for testing Earley&quot;</span>
            <span class="label">~initial_nt</span><span class="operator">:</span>_E
            <span class="label">~rules</span><span class="operator">:[</span>
              _E <span class="operator">--&gt;</span>_3 <span class="operator">(</span>nt _E<span class="operator">,</span>nt _E<span class="operator">,</span>nt _E<span class="operator">)</span> <span class="operator">(</span><span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">x</span><span class="operator">,</span><span class="variable-name">y</span><span class="operator">,</span><span class="variable-name">z</span><span class="operator">)</span> <span class="operator">-&gt;</span> x<span class="operator">+</span>y<span class="operator">+</span>z<span class="operator">);</span>
              _E <span class="operator">--&gt;</span>_1 one <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span> 1<span class="operator">);</span>
              _E <span class="operator">--&gt;</span>_1 eps <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span> 0<span class="operator">);</span>
            <span class="operator">]</span>
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="variable-name">aho_s</span> <span class="operator">=</span> 
          grammar
            <span class="label">~name</span><span class="operator">:</span><span class="string">&quot;aho_s&quot;</span>
            <span class="label">~descr</span><span class="operator">:</span><span class="string">&quot;Aho et al. example grammar&quot;</span>
            <span class="label">~initial_nt</span><span class="operator">:</span>_S
            <span class="label">~rules</span><span class="operator">:[</span>
              _S <span class="operator">--&gt;</span>_3 <span class="operator">(</span>x<span class="operator">,</span>nt _S<span class="operator">,</span>nt _S<span class="operator">)</span> <span class="operator">(</span><span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">x</span><span class="operator">,</span><span class="variable-name">y</span><span class="operator">,</span><span class="variable-name">z</span><span class="operator">)</span> <span class="operator">-&gt;</span> <span class="string">&quot;x&quot;</span><span class="operator">^</span>y<span class="operator">^</span>z<span class="operator">);</span>
              _S <span class="operator">--&gt;</span>_1 eps <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span> <span class="string">&quot;&quot;</span><span class="operator">)</span>
            <span class="operator">]</span>
        <span class="governing">in</span>
        <span class="operator">(</span>_EEE<span class="operator">,</span>aho_s<span class="operator">)</span>
    
      <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> example_grammars
    <span class="governing">end</span>
    
    <span class="doc">(** Internal2: translate grammars to untyped representation *)</span>
    <span class="governing">module</span> <span class="module">Internal2</span><span class="operator">(</span><span class="variable-name">B</span><span class="operator">:</span><span class="module">INTERNAL2_REQS</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">=</span> <span class="governing">struct</span>
      <span class="governing">open </span><span class="module">B</span>
    
      <span class="governing">type</span> <span class="type">u_rhs</span> <span class="operator">=</span> u_sym list <span class="operator">*</span> <span class="operator">(</span>uni_val list <span class="operator">-&gt;</span> uni_val<span class="operator">)</span>
      <span class="governing">type</span> <span class="type">rule</span> <span class="operator">=</span> u_nt <span class="operator">*</span> u_rhs
    
      <span class="governing">type</span> <span class="type">'a rhs</span> <span class="operator">=</span> u_rhs
    
      <span class="governing">let</span> <span class="function-name">_1</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">_S</span><span class="operator">:</span><span class="type">'a sym</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">f</span><span class="operator">:</span><span class="type">'a </span><span class="operator">-&gt;</span><span class="type"> 'b</span><span class="operator">)</span> <span class="operator">:</span> <span class="type">'b rhs</span> <span class="operator">=</span> 
        <span class="operator">([</span>sym2u _S<span class="operator">],</span> <span class="keyword">fun</span> <span class="operator">[</span>v<span class="operator">]</span> <span class="operator">-&gt;</span> <span class="module">Obj.</span>magic <span class="operator">(</span>f <span class="operator">(</span><span class="module">Obj.</span>magic v<span class="operator">)))</span>
    
      <span class="governing">let</span> <span class="variable-name">_2</span><span class="operator">:</span> <span class="operator">(</span><span class="type">'a sym </span><span class="operator">*</span><span class="type"> 'b sym</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> </span><span class="operator">(</span><span class="type">'a </span><span class="operator">*</span><span class="type"> 'b </span><span class="operator">-&gt;</span><span class="type"> 'c</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> 'c rhs </span><span class="operator">=</span> 
        <span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">s1</span><span class="operator">,</span><span class="variable-name">s2</span><span class="operator">)</span><span class="variable-name"> f</span> <span class="operator">-&gt;</span>
        <span class="operator">([</span>sym2u s1<span class="operator">;</span> sym2u s2<span class="operator">],</span> <span class="keyword">fun</span><span class="operator">[</span>v1<span class="operator">;</span>v2<span class="operator">]</span> <span class="operator">-&gt;</span> <span class="module">Obj.</span>magic <span class="operator">(</span>f <span class="operator">(</span><span class="module">Obj.</span>magic v1<span class="operator">,</span> <span class="module">Obj.</span>magic v2<span class="operator">)))</span>
    
      <span class="governing">let</span> <span class="variable-name">_3</span><span class="operator">:</span> <span class="operator">(</span><span class="type">'a sym </span><span class="operator">*</span><span class="type"> 'b sym </span><span class="operator">*</span><span class="type"> 'c sym</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> </span><span class="operator">(</span><span class="type">'a </span><span class="operator">*</span><span class="type"> 'b </span><span class="operator">*</span><span class="type"> 'c </span><span class="operator">-&gt;</span><span class="type"> 'd</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> 'd rhs </span><span class="operator">=</span>
        <span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">s1</span><span class="operator">,</span><span class="variable-name">s2</span><span class="operator">,</span><span class="variable-name">s3</span><span class="operator">)</span><span class="variable-name"> f</span> <span class="operator">-&gt;</span>
        <span class="operator">[</span>sym2u s1<span class="operator">;</span> sym2u s2<span class="operator">;</span> sym2u s3<span class="operator">],</span>
        <span class="keyword">fun</span> <span class="operator">[</span>v1<span class="operator">;</span>v2<span class="operator">;</span>v3<span class="operator">]</span> <span class="operator">-&gt;</span> <span class="module">Obj.</span>magic <span class="operator">(</span>f <span class="operator">(</span><span class="module">Obj.</span>magic v1<span class="operator">,</span> <span class="module">Obj.</span>magic v2<span class="operator">,</span> <span class="module">Obj.</span>magic v3<span class="operator">))</span>
    
      <span class="governing">let</span> <span class="function-name">mk_rule</span> <span class="operator">:</span> <span class="type">'a nt </span><span class="operator">-&gt;</span><span class="type"> 'a rhs </span><span class="operator">-&gt;</span><span class="type"> rule </span><span class="operator">=</span> <span class="keyword">fun</span> <span class="variable-name">nt rhs</span> <span class="operator">-&gt;</span> <span class="operator">(</span>nt2u nt<span class="operator">,</span>rhs<span class="operator">)</span>
      <span class="governing">let</span> <span class="operator">(</span><span class="variable-name"> </span><span class="operator">--&gt;</span><span class="variable-name"> </span><span class="operator">)</span> <span class="operator">=</span> mk_rule
    
      <span class="governing">type</span> <span class="type">'a grammar</span> <span class="operator">=</span> <span class="operator">{</span>
        name<span class="operator">:</span>string<span class="operator">;</span>
        descr<span class="operator">:</span>string<span class="operator">;</span>
        initial_nt<span class="operator">:</span>'a nt<span class="operator">;</span>
        rules<span class="operator">:</span>u_nt <span class="operator">-&gt;</span> u_rhs list
      <span class="operator">}</span> 
    
      <span class="governing">let</span> <span class="variable-name">grammar</span><span class="operator">:</span> <span class="label">name</span><span class="operator">:</span><span class="type">string </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">descr</span><span class="operator">:</span><span class="type">string </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">initial_nt</span><span class="operator">:</span><span class="type">'a nt </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">rules</span><span class="operator">:</span><span class="type">rule list </span><span class="operator">-&gt;</span><span class="type"> 'a grammar 
        </span><span class="operator">=</span>
        <span class="keyword">fun</span> <span class="operator">~</span><span class="variable-name">name </span><span class="operator">~</span><span class="variable-name">descr </span><span class="operator">~</span><span class="variable-name">initial_nt </span><span class="operator">~</span><span class="variable-name">rules</span> <span class="operator">-&gt;</span> 
        <span class="governing">let</span> <span class="variable-name">tbl</span> <span class="operator">=</span> <span class="module">Hashtbl.</span>create 100 <span class="governing">in</span>
        <span class="module">List.</span>rev rules <span class="operator">|&gt;</span> <span class="module">List.</span>iter <span class="operator">(</span><span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">nt</span><span class="operator">,</span><span class="variable-name">rhs</span><span class="operator">)</span> <span class="operator">-&gt;</span> 
            <span class="module">Hashtbl.</span>find_opt tbl nt <span class="operator">|&gt;</span> <span class="keyword">function</span>
            <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="module">Hashtbl.</span>replace tbl nt <span class="operator">[</span>rhs<span class="operator">]</span>
            <span class="operator">|</span> <span class="constructor">Some</span> rhss <span class="operator">-&gt;</span> <span class="module">Hashtbl.</span>replace tbl nt <span class="operator">(</span>rhs<span class="operator">::</span>rhss<span class="operator">));</span>
        <span class="governing">let</span> <span class="function-name">rules</span><span class="variable-name"> nt</span> <span class="operator">=</span> <span class="module">Hashtbl.</span>find_opt tbl nt <span class="operator">|&gt;</span> <span class="keyword">function</span>
          <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="operator">[]</span>
          <span class="operator">|</span> <span class="constructor">Some</span> rhss <span class="operator">-&gt;</span> rhss
        <span class="governing">in</span>
        <span class="operator">{</span> name<span class="operator">;</span> descr<span class="operator">;</span> initial_nt<span class="operator">;</span> rules <span class="operator">}</span>
    <span class="governing">end</span>
    
    
    <span class="governing">module</span> <span class="module">Internal3</span> <span class="operator">=</span> <span class="governing">struct</span>
    
      <span class="comment-delimiter">(* </span><span class="comment">Implementation of INTERNAL2_REQS </span><span class="comment-delimiter">*)</span>
      <span class="governing">module</span> <span class="module">Internal2_reqs</span> <span class="operator">:</span> <span class="governing">sig</span>
        <span class="governing">type</span> <span class="type">'a nt</span>
    
        <span class="doc">(** For debugging, make u_nt a string *)</span>
        <span class="governing">type</span> <span class="type">u_nt</span> <span class="operator">=</span> string 
        <span class="governing">val</span> <span class="function-name">nt2u</span> <span class="operator">:</span> 'a nt <span class="operator">-&gt;</span> u_nt
    
        <span class="governing">type</span> <span class="type">'a tm</span>
        <span class="governing">type</span> <span class="type">u_tm</span> <span class="operator">=</span> string
    
    
        <span class="governing">type</span> <span class="type">'a sym</span>
        <span class="governing">type</span> <span class="type">u_sym</span> <span class="operator">=</span> <span class="operator">(</span>u_nt<span class="operator">,</span>u_tm<span class="operator">)</span><span class="module">Prelude.</span>generic_sym
        <span class="governing">val</span> <span class="function-name">sym2u</span> <span class="operator">:</span> 'a sym <span class="operator">-&gt;</span> u_sym
        <span class="governing">type</span> <span class="type">uni_val</span>
        <span class="governing">val</span> <span class="function-name">nt</span> <span class="operator">:</span> 'a nt <span class="operator">-&gt;</span> 'a sym
        <span class="governing">val</span> <span class="function-name">tm</span><span class="operator">:</span> 'a tm <span class="operator">-&gt;</span> 'a sym
        <span class="governing">val</span> <span class="function-name">_E</span> <span class="operator">:</span> int nt
        <span class="governing">val</span> <span class="function-name">_S</span> <span class="operator">:</span> string nt
        <span class="governing">val</span> <span class="function-name">a</span> <span class="operator">:</span> string <span class="operator">-&gt;</span> string tm
      <span class="governing">end</span> <span class="operator">=</span> <span class="governing">struct</span>
        <span class="governing">type</span> <span class="type">'a nt</span> <span class="operator">=</span> string
        <span class="governing">type</span> <span class="type">u_nt</span> <span class="operator">=</span> string
        <span class="governing">let</span> <span class="function-name">nt2u</span> <span class="operator">:</span> <span class="type">'a nt </span><span class="operator">-&gt;</span><span class="type"> u_nt </span><span class="operator">=</span> <span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> x
    
        <span class="governing">type</span> <span class="type">'a tm</span> <span class="operator">=</span> string
        <span class="governing">type</span> <span class="type">u_tm</span> <span class="operator">=</span> string
    
        <span class="governing">type</span> <span class="type">u_sym</span> <span class="operator">=</span> <span class="operator">(</span>u_nt<span class="operator">,</span>u_tm<span class="operator">)</span><span class="module">Prelude.</span>generic_sym
        <span class="governing">type</span> <span class="type">'a sym</span> <span class="operator">=</span> u_sym
        <span class="governing">let</span> <span class="function-name">sym2u</span> <span class="operator">:</span> <span class="type">'a sym </span><span class="operator">-&gt;</span><span class="type"> u_sym </span><span class="operator">=</span> <span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> x
        <span class="governing">type</span> <span class="type">uni_val</span>
    
        <span class="governing">let</span> <span class="function-name">u_nt2string</span><span class="variable-name"> x</span> <span class="operator">=</span> x
        <span class="governing">let</span> <span class="function-name">u_sym2string</span><span class="variable-name"> x</span> <span class="operator">=</span> x
    
        <span class="comment-delimiter">(* </span><span class="comment">from A ; FIXME </span><span class="comment-delimiter">*)</span>
        <span class="governing">let</span> <span class="function-name">nt</span> <span class="operator">:</span> <span class="type">'a nt </span><span class="operator">-&gt;</span><span class="type"> 'a sym </span><span class="operator">=</span> <span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> <span class="constructor">Nt</span> x
        <span class="governing">let</span> <span class="function-name">tm</span> <span class="operator">:</span> <span class="type">'a tm </span><span class="operator">-&gt;</span><span class="type"> 'a sym </span><span class="operator">=</span> <span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> <span class="constructor">Tm</span> x
    
        <span class="governing">let</span> <span class="variable-name">_E</span> <span class="operator">:</span> <span class="type">int nt </span><span class="operator">=</span><span class="string">&quot;E&quot;</span>
        <span class="governing">let</span> <span class="variable-name">_S</span> <span class="operator">:</span> <span class="type">string nt </span><span class="operator">=</span> <span class="string">&quot;S&quot;</span>
        <span class="governing">let</span> <span class="function-name">a</span><span class="variable-name"> s</span> <span class="operator">=</span> s
      <span class="governing">end</span>
    
      <span class="doc">(** NOTE use Internal2 *)</span>
      <span class="governing">module</span> <span class="module">C</span> <span class="operator">=</span> <span class="module">Internal2</span><span class="operator">(</span><span class="module">Internal2_reqs</span><span class="operator">)</span>
    
      <span class="governing">module</span> <span class="module">A2</span> <span class="operator">=</span> <span class="governing">struct</span>
        <span class="governing">include</span> <span class="module">Internal2_reqs</span>
        <span class="governing">include</span> <span class="module">C</span>
      <span class="governing">end</span>
    
      <span class="governing">module</span> <span class="module">D</span> <span class="operator">:</span> <span class="module">INTERNAL_REQS</span> <span class="operator">=</span> <span class="module">A2</span>
    
      <span class="doc">(** NOTE use Internal *)</span>
      <span class="governing">module</span> <span class="module">F</span> <span class="operator">=</span> <span class="module">Internal</span><span class="operator">(</span><span class="module">A2</span><span class="operator">)</span>
    
      <span class="doc">(** Export abstract interface. *)</span>
      <span class="governing">module</span> <span class="module">Export</span> <span class="operator">:</span> <span class="governing">sig</span>
        <span class="governing">type</span> <span class="type">'a grammar</span> <span class="operator">=</span> 'a <span class="module">C.</span>grammar
        <span class="governing">val</span> <span class="function-name">_EEE</span> <span class="operator">:</span> int grammar
        <span class="governing">val</span> <span class="function-name">aho_s</span> <span class="operator">:</span> string grammar
      <span class="governing">end</span> <span class="operator">=</span> <span class="governing">struct</span>
        <span class="governing">type</span> <span class="type">'a grammar</span> <span class="operator">=</span> 'a <span class="module">C.</span>grammar
        <span class="governing">let</span> <span class="variable-name">example_grammars</span> <span class="operator">=</span> <span class="module">F.</span>example_grammars
        <span class="governing">let</span> <span class="variable-name">_EEE</span><span class="operator">,</span><span class="variable-name">aho_s</span> <span class="operator">=</span> example_grammars
      <span class="governing">end</span>
      
    <span class="governing">end</span>
    
    <span class="governing">open </span><span class="module">Internal3</span>
    
    <span class="comment-delimiter">(* </span><span class="comment">include Internal3.Internal2_reqs </span><span class="comment-delimiter">*)</span>
    
    <span class="doc">(** NOTE following types are present in the ['a grammar] type *)</span>
    
    <span class="doc">(** Just a string *)</span>
    <span class="governing">type</span> <span class="type">u_nt</span> <span class="operator">=</span> <span class="module">Internal3.Internal2_reqs.</span>u_nt 
    
    <span class="governing">type</span> <span class="type">'a nt</span> <span class="operator">=</span> 'a <span class="module">Internal3.Internal2_reqs.</span>nt
    <span class="governing">let</span> <span class="variable-name">nt2u</span><span class="operator">:</span> <span class="type">'a nt </span><span class="operator">-&gt;</span><span class="type"> u_nt </span><span class="operator">=</span> <span class="module">Internal3.Internal2_reqs.</span>nt2u
    
    <span class="doc">(** Just a string *)</span>
    <span class="governing">type</span> <span class="type">u_tm</span> <span class="operator">=</span> <span class="module">Internal3.Internal2_reqs.</span>u_tm 
    
    <span class="doc">(** A [generic_sym] over u_nt and u_tm *)</span>
    <span class="governing">type</span> <span class="type">u_sym</span> <span class="operator">=</span> <span class="module">Internal2_reqs.</span>u_sym
    
    <span class="doc">(** Used for actions *)</span>
    <span class="governing">type</span> <span class="type">uni_val</span> <span class="operator">=</span> <span class="module">Internal2_reqs.</span>uni_val
    
    <span class="doc">(** A list of u_sym, and an action *)</span>
    <span class="governing">type</span> <span class="type">u_rhs</span> <span class="operator">=</span> <span class="module">Internal3.C.</span>u_rhs
    
    
    <span class="governing">type</span> <span class="type">'a grammar</span> <span class="operator">=</span> 'a <span class="module">Internal3.C.</span>grammar
    
    
    <span class="governing">let</span> <span class="variable-name">_EEE</span> <span class="operator">:</span> <span class="type">int grammar </span><span class="operator">=</span> <span class="module">Internal3.Export.</span>_EEE
    <span class="governing">let</span> <span class="variable-name">aho_s</span> <span class="operator">:</span> <span class="type">string grammar </span><span class="operator">=</span> <span class="module">Internal3.Export.</span>aho_s
    
    
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Examples</span> <span class="operator">=</span> <span class="governing">struct</span> 
    <span class="doc">(** Some examples *)</span>
    
    
    <span class="doc">(** Example grammar
       names are: EEE, aho_s, aho_sml, brackets, S_xSx 
    
    {%html:
    
    &lt;pre&gt;
        let _EEE = 
          p#grammar 
            ~name:&quot;EEE&quot;
            ~descr:&quot;Very ambiguous grammar, for testing Earley&quot;
            ~initial_nt:_E
            ~rules:[
              _E --&gt;_3 (_E,_E,_E);
              _E --&gt;_1 one;
              _E --&gt;_1 eps;
            ]
        in
        let aho_s = 
          p#grammar
            ~name:&quot;aho_s&quot;
            ~descr:&quot;Aho et al. example grammar&quot;
            ~initial_nt:_S
            ~rules:[
              _S --&gt;_3 (x,_S,_S);
              _S --&gt;_1 eps
            ]
        in
        let aho_sml = 
          p#grammar
            ~name:&quot;aho_sml&quot;
            ~descr:&quot;Aho et al. example grammar 2&quot;
            ~initial_nt:_S
            ~rules:[
              _S --&gt;_3 (_S,_S,x);
              _S --&gt;_1 eps
            ]
        in
        let brackets = 
          p#grammar
            ~name:&quot;brackets&quot;
            ~descr:
              &quot;Well-bracketed expressions, in a particular nasty form for parsing&quot;
            ~initial_nt:_E
            ~rules:[
              _E --&gt;_2 (_E,_E);
              _E --&gt;_3 (a&quot;(&quot;,_E,a&quot;)&quot;);
              _E --&gt;_1 eps
            ]
        in
        let _S_xSx = 
          p#grammar 
            ~name:&quot;S_xSx&quot;
            ~descr:&quot;Unambiguous grammar that favours right-most parsers&quot;
            ~initial_nt:_S
            ~rules:[
              _S --&gt;_3 (x,_S,x);
              _S --&gt;_1 x
            ]
        in
    &lt;/pre&gt;
    
    %}
    
    *)</span>
    
    
    <span class="doc">(** Internal: grammmars defined abstractly. NOTE the following assumes
       nt, tm and sym are all the same type. *)</span>
    <span class="governing">module</span> <span class="module">Internal</span> <span class="operator">=</span> <span class="governing">struct</span>
    
      <span class="governing">let</span> <span class="function-name">example_grammars</span><span class="variable-name"> p</span> <span class="operator">=</span>
        <span class="governing">let</span> <span class="operator">(</span><span class="variable-name"> </span><span class="operator">--&gt;</span><span class="variable-name"> </span><span class="operator">)</span> <span class="operator">=</span> p<span class="operator">#</span>make_rule <span class="governing">in</span>
        <span class="governing">let</span> <span class="variable-name">_1</span><span class="operator">,</span><span class="variable-name">_2</span><span class="operator">,</span><span class="variable-name">_3</span> <span class="operator">=</span> p<span class="operator">#</span>_1<span class="operator">,</span>p<span class="operator">#</span>_2<span class="operator">,</span>p<span class="operator">#</span>_3 <span class="governing">in</span>
        <span class="governing">let</span> <span class="variable-name">_E</span><span class="operator">,</span><span class="variable-name">_S</span><span class="operator">,</span><span class="variable-name">a</span> <span class="operator">=</span> p<span class="operator">#</span>_E<span class="operator">,</span>p<span class="operator">#</span>_S<span class="operator">,</span>p<span class="operator">#</span>a <span class="governing">in</span>
        <span class="governing">let</span> <span class="operator">[</span>one<span class="operator">;</span>eps<span class="operator">;</span>x<span class="operator">]</span> <span class="operator">=</span> <span class="module">List.</span>map a <span class="operator">[</span><span class="string">&quot;1&quot;</span><span class="operator">;</span><span class="string">&quot;&quot;</span><span class="operator">;</span><span class="string">&quot;x&quot;</span><span class="operator">]</span> <span class="governing">in</span>
        <span class="governing">let</span> <span class="variable-name">_EEE</span> <span class="operator">=</span> 
          p<span class="operator">#</span>grammar 
            <span class="label">~name</span><span class="operator">:</span><span class="string">&quot;EEE&quot;</span>
            <span class="label">~descr</span><span class="operator">:</span><span class="string">&quot;Very ambiguous grammar, for testing Earley&quot;</span>
            <span class="label">~initial_nt</span><span class="operator">:</span>_E
            <span class="label">~rules</span><span class="operator">:[</span>
              _E <span class="operator">--&gt;</span>_3 <span class="operator">(</span>_E<span class="operator">,</span>_E<span class="operator">,</span>_E<span class="operator">);</span>
              _E <span class="operator">--&gt;</span>_1 one<span class="operator">;</span>
              _E <span class="operator">--&gt;</span>_1 eps<span class="operator">;</span>
            <span class="operator">]</span>
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="variable-name">aho_s</span> <span class="operator">=</span> 
          p<span class="operator">#</span>grammar
            <span class="label">~name</span><span class="operator">:</span><span class="string">&quot;aho_s&quot;</span>
            <span class="label">~descr</span><span class="operator">:</span><span class="string">&quot;Aho et al. example grammar&quot;</span>
            <span class="label">~initial_nt</span><span class="operator">:</span>_S
            <span class="label">~rules</span><span class="operator">:[</span>
              _S <span class="operator">--&gt;</span>_3 <span class="operator">(</span>x<span class="operator">,</span>_S<span class="operator">,</span>_S<span class="operator">);</span>
              _S <span class="operator">--&gt;</span>_1 eps
            <span class="operator">]</span>
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="variable-name">aho_sml</span> <span class="operator">=</span> 
          p<span class="operator">#</span>grammar
            <span class="label">~name</span><span class="operator">:</span><span class="string">&quot;aho_sml&quot;</span>
            <span class="label">~descr</span><span class="operator">:</span><span class="string">&quot;Aho et al. example grammar 2&quot;</span>
            <span class="label">~initial_nt</span><span class="operator">:</span>_S
            <span class="label">~rules</span><span class="operator">:[</span>
              _S <span class="operator">--&gt;</span>_3 <span class="operator">(</span>_S<span class="operator">,</span>_S<span class="operator">,</span>x<span class="operator">);</span>
              _S <span class="operator">--&gt;</span>_1 eps
            <span class="operator">]</span>
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="variable-name">brackets</span> <span class="operator">=</span> 
          p<span class="operator">#</span>grammar
            <span class="label">~name</span><span class="operator">:</span><span class="string">&quot;brackets&quot;</span>
            <span class="label">~descr</span><span class="operator">:</span>
              <span class="string">&quot;Well-bracketed expressions, in a particular nasty form for parsing&quot;</span>
            <span class="label">~initial_nt</span><span class="operator">:</span>_E
            <span class="label">~rules</span><span class="operator">:[</span>
              _E <span class="operator">--&gt;</span>_2 <span class="operator">(</span>_E<span class="operator">,</span>_E<span class="operator">);</span>
              _E <span class="operator">--&gt;</span>_3 <span class="operator">(</span>a<span class="string">&quot;(&quot;</span><span class="operator">,</span>_E<span class="operator">,</span>a<span class="string">&quot;)&quot;</span><span class="operator">);</span>
              _E <span class="operator">--&gt;</span>_1 eps
            <span class="operator">]</span>
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="variable-name">_S_xSx</span> <span class="operator">=</span> 
          p<span class="operator">#</span>grammar 
            <span class="label">~name</span><span class="operator">:</span><span class="string">&quot;S_xSx&quot;</span>
            <span class="label">~descr</span><span class="operator">:</span><span class="string">&quot;Unambiguous grammar that favours right-most parsers&quot;</span>
            <span class="label">~initial_nt</span><span class="operator">:</span>_S
            <span class="label">~rules</span><span class="operator">:[</span>
              _S <span class="operator">--&gt;</span>_3 <span class="operator">(</span>x<span class="operator">,</span>_S<span class="operator">,</span>x<span class="operator">);</span>
              _S <span class="operator">--&gt;</span>_1 x
            <span class="operator">]</span>
        <span class="governing">in</span>
        <span class="operator">[</span>_EEE<span class="operator">;</span>aho_s<span class="operator">;</span>aho_sml<span class="operator">;</span>brackets<span class="operator">;</span>_S_xSx<span class="operator">]</span>
    
      <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> example_grammars
    <span class="governing">end</span>
    
    
    
    <span class="doc">(** Example instantiation with strings for symbols *)</span>
    <span class="governing">module</span> <span class="module">Internal_example_instantiation</span> <span class="operator">=</span> <span class="governing">struct</span>
    
      <span class="doc">(** A named tuple for tagging grammars in a slightly more digestible
          form than a plain tuple *)</span>
      <span class="governing">type</span> <span class="operator">(</span><span class="type">'a</span><span class="operator">,</span><span class="type">'b</span><span class="operator">)</span><span class="type"> grammar</span> <span class="operator">=</span> <span class="operator">{</span>
        name<span class="operator">:</span>string<span class="operator">;</span>
        descr<span class="operator">:</span>string<span class="operator">;</span>
        initial_nt<span class="operator">:</span>'a<span class="operator">;</span>
        rules<span class="operator">:</span>'b
      <span class="operator">}</span>
    
    
      <span class="governing">open </span><span class="module">Prelude</span>
    
      <span class="governing">type</span> <span class="type">nt</span> <span class="operator">=</span> string
      <span class="governing">type</span> <span class="type">tm</span> <span class="operator">=</span> string
      <span class="governing">type</span> <span class="type">sym</span> <span class="operator">=</span> <span class="operator">(</span>nt<span class="operator">,</span>tm<span class="operator">)</span> <span class="module">Prelude.</span>generic_sym
      <span class="governing">type</span> <span class="type">rule</span> <span class="operator">=</span> nt <span class="operator">*</span> sym list
    
      <span class="doc">(** Hack to determine nt/tm based on string repr starting with a
          capital letter *)</span>
      <span class="governing">let</span> <span class="function-name">is_nt</span><span class="variable-name"> nt</span> <span class="operator">=</span> nt <span class="operator">&lt;&gt;</span> <span class="string">&quot;&quot;</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span><span class="module">String.</span>get nt 0 <span class="operator">|&gt;</span> <span class="keyword">function</span>
        <span class="operator">|</span> <span class="string">'</span><span class="string">A</span><span class="string">'</span> <span class="operator">..</span> <span class="string">'</span><span class="string">Z</span><span class="string">'</span> <span class="operator">-&gt;</span> <span class="constant">true</span>
        <span class="operator">|</span> _ <span class="operator">-&gt;</span> <span class="constant">false</span><span class="operator">)</span>
    
      <span class="governing">let</span> <span class="function-name">string_to_sym</span><span class="variable-name"> s</span> <span class="operator">=</span> <span class="keyword">match</span> is_nt s <span class="keyword">with</span> 
        <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> <span class="constructor">Nt</span> s
        <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> <span class="constructor">Tm</span> s
    
      <span class="governing">let</span> <span class="function-name">make_rule</span><span class="variable-name"> nt rhs</span> <span class="operator">=</span> <span class="operator">(</span>nt<span class="operator">,</span>rhs<span class="operator">|&gt;</span><span class="module">List.</span>map string_to_sym<span class="operator">)</span>
    
      <span class="governing">let</span> <span class="function-name">_1</span><span class="variable-name"> s</span> <span class="operator">=</span> <span class="operator">[</span>s<span class="operator">]</span>
      <span class="governing">let</span> <span class="function-name">_2</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">s1</span><span class="operator">,</span><span class="variable-name">s2</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">[</span>s1<span class="operator">;</span>s2<span class="operator">]</span>
      <span class="governing">let</span> <span class="function-name">_3</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">s1</span><span class="operator">,</span><span class="variable-name">s2</span><span class="operator">,</span><span class="variable-name">s3</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">[</span>s1<span class="operator">;</span>s2<span class="operator">;</span>s3<span class="operator">]</span>
    
      <span class="governing">let</span> <span class="variable-name">_E</span> <span class="operator">=</span> <span class="string">&quot;E&quot;</span>
      <span class="governing">let</span> <span class="variable-name">_S</span> <span class="operator">=</span> <span class="string">&quot;S&quot;</span>
      <span class="governing">let</span> <span class="function-name">a</span><span class="variable-name"> s</span> <span class="operator">=</span> s
      <span class="governing">let</span> <span class="variable-name">eps</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>
      <span class="governing">let</span> <span class="variable-name">one</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>
      <span class="governing">let</span> <span class="variable-name">x</span> <span class="operator">=</span> <span class="string">&quot;x&quot;</span>
    
      <span class="governing">let</span> <span class="function-name">grammar</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">name </span><span class="operator">~</span><span class="variable-name">descr </span><span class="operator">~</span><span class="variable-name">initial_nt </span><span class="operator">~</span><span class="variable-name">rules</span> <span class="operator">=</span> <span class="operator">{</span>name<span class="operator">;</span>descr<span class="operator">;</span>initial_nt<span class="operator">;</span>rules<span class="operator">}</span>
    
      <span class="governing">let</span> <span class="variable-name">example_grammars</span> <span class="operator">=</span> 
        <span class="governing">let</span> <span class="variable-name">p</span> <span class="operator">=</span> <span class="governing">object</span>
          <span class="governing">method</span> <span class="function-name">_1</span> <span class="operator">=</span> _1
          <span class="governing">method</span> <span class="function-name">_2</span> <span class="operator">=</span> _2
          <span class="governing">method</span> <span class="function-name">_3</span> <span class="operator">=</span> _3
          <span class="governing">method</span> <span class="function-name">make_rule</span> <span class="operator">=</span> make_rule
          <span class="governing">method</span> <span class="function-name">grammar</span> <span class="operator">=</span> grammar
          <span class="governing">method</span> <span class="function-name">_E</span> <span class="operator">=</span> _E
          <span class="governing">method</span> <span class="function-name">_S</span> <span class="operator">=</span> _S
          <span class="governing">method</span> <span class="function-name">a</span> <span class="operator">=</span> a
          <span class="governing">method</span> <span class="function-name">eps</span> <span class="operator">=</span> eps
          <span class="governing">method</span> <span class="function-name">one</span> <span class="operator">=</span> one
          <span class="governing">method</span> <span class="function-name">x</span> <span class="operator">=</span> x
          <span class="governing">end</span>
        <span class="governing">in</span>
        <span class="module">Internal.</span>example_grammars p
    
      <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> example_grammars
    
      <span class="governing">module</span> <span class="module">Export</span> <span class="operator">=</span> <span class="governing">struct</span>
    
        <span class="doc">(** NOTE nonterminals and terminals are represented by strings *)</span>
    
        <span class="governing">let</span> <span class="variable-name">grammar_names</span> <span class="operator">=</span> <span class="operator">[</span><span class="string">&quot;EEE&quot;</span><span class="operator">;</span><span class="string">&quot;aho_s&quot;</span><span class="operator">;</span><span class="string">&quot;aho_sml&quot;</span><span class="operator">;</span><span class="string">&quot;brackets&quot;</span><span class="operator">;</span><span class="string">&quot;S_xSx&quot;</span><span class="operator">]</span>
    
        <span class="governing">let</span> <span class="function-name">get_grammar_by_name</span><span class="variable-name"> name</span> <span class="operator">:</span> <span class="operator">(</span><span class="type">nt</span><span class="operator">,</span><span class="type">tm</span><span class="operator">)</span><span class="type"> </span><span class="module">Prelude.</span><span class="type">simple_grammar </span><span class="operator">*</span><span class="type"> nt</span> <span class="operator">=</span> 
          <span class="governing">let</span> <span class="variable-name">g</span> <span class="operator">=</span> example_grammars <span class="operator">|&gt;</span> <span class="module">List.</span>find <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">g</span> <span class="operator">-&gt;</span> g.name <span class="operator">=</span> name<span class="operator">)</span> <span class="governing">in</span>
          <span class="governing">let</span> <span class="variable-name">tbl</span> <span class="operator">=</span> <span class="module">Hashtbl.</span>create 100 <span class="governing">in</span>
          <span class="module">List.</span>rev g.rules <span class="operator">|&gt;</span> <span class="module">List.</span>iter <span class="operator">(</span><span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">nt</span><span class="operator">,</span><span class="variable-name">rhs</span><span class="operator">)</span> <span class="operator">-&gt;</span> 
            <span class="module">Hashtbl.</span>find_opt tbl nt <span class="operator">|&gt;</span> <span class="keyword">function</span>
            <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="module">Hashtbl.</span>replace tbl nt <span class="operator">[</span>rhs<span class="operator">]</span>
            <span class="operator">|</span> <span class="constructor">Some</span> rhss <span class="operator">-&gt;</span> <span class="module">Hashtbl.</span>replace tbl nt <span class="operator">(</span>rhs<span class="operator">::</span>rhss<span class="operator">));</span>
          <span class="governing">let</span> <span class="function-name">nt_to_rhss</span><span class="variable-name"> nt</span> <span class="operator">=</span> <span class="module">Hashtbl.</span>find_opt tbl nt <span class="operator">|&gt;</span> <span class="keyword">function</span>
          <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="operator">[]</span>
          <span class="operator">|</span> <span class="constructor">Some</span> rhss <span class="operator">-&gt;</span> rhss
          <span class="governing">in</span>
          <span class="module">Prelude.</span><span class="operator">({</span>nt_to_rhss<span class="operator">},</span>g.initial_nt<span class="operator">)</span>
    
    
      <span class="governing">end</span>
      
    <span class="governing">end</span>
    
    <span class="governing">include</span> <span class="module">Internal_example_instantiation.Export</span>
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Earley_spec</span> <span class="operator">=</span> <span class="governing">struct</span> 
    <span class="doc">(** A simple specification of general parsing (not only Earley). For
       the implementation, see {!Earley_unstaged}. *)</span>
    
    <span class="governing">open </span><span class="module">Prelude</span>
    
    <span class="governing">module</span> <span class="governing">type</span> <span class="module">REQUIRED</span> <span class="operator">=</span> <span class="governing">sig</span>
      <span class="governing">include</span> <span class="module">Prelude.REQUIRED</span>
      <span class="governing">type</span> <span class="type">sym_item</span> <span class="operator">=</span> <span class="operator">{</span> i_<span class="operator">:</span>int<span class="operator">;</span> sym<span class="operator">:</span>sym<span class="operator">;</span> j_<span class="operator">:</span>int <span class="operator">}</span>
      <span class="governing">type</span> <span class="type">sym_at_k</span> <span class="operator">=</span> <span class="operator">{</span> sym<span class="operator">:</span>sym<span class="operator">;</span> k_<span class="operator">:</span>int <span class="operator">}</span> 
    
      <span class="governing">type</span> <span class="type">item</span> <span class="operator">=</span> 
        <span class="operator">|</span> <span class="constructor">Nt_item</span> <span class="keyword">of</span> nt_item
        <span class="operator">|</span> <span class="constructor">Sym_item</span> <span class="keyword">of</span> sym_item
        <span class="operator">|</span> <span class="constructor">Sym_at_k</span> <span class="keyword">of</span> sym_at_k
    <span class="governing">end</span>
    
    <span class="governing">module</span> <span class="module">Make_extra_items</span><span class="operator">(</span><span class="constructor">A</span><span class="operator">:</span><span class="governing">sig</span> <span class="governing">type</span> <span class="type">sym</span> <span class="governing">type</span> <span class="type">nt_item</span> <span class="governing">end</span><span class="operator">)</span> <span class="operator">=</span> <span class="governing">struct</span>
      <span class="governing">open </span><span class="module">A</span>
      <span class="governing">type</span> <span class="type">sym_item</span> <span class="operator">=</span> <span class="operator">{</span> i_<span class="operator">:</span>int<span class="operator">;</span> sym<span class="operator">:</span>sym<span class="operator">;</span> j_<span class="operator">:</span>int <span class="operator">}</span>
      <span class="governing">type</span> <span class="type">sym_at_k</span> <span class="operator">=</span> <span class="operator">{</span> sym<span class="operator">:</span>sym<span class="operator">;</span> k_<span class="operator">:</span>int <span class="operator">}</span> 
    
      <span class="governing">type</span> <span class="type">item</span> <span class="operator">=</span> 
        <span class="operator">|</span> <span class="constructor">Nt_item</span> <span class="keyword">of</span> nt_item
        <span class="operator">|</span> <span class="constructor">Sym_item</span> <span class="keyword">of</span> sym_item
        <span class="operator">|</span> <span class="constructor">Sym_at_k</span> <span class="keyword">of</span> sym_at_k
    <span class="governing">end</span>
    
    <span class="doc">(** Internal implementation *)</span>
    <span class="governing">module</span> <span class="module">Internal</span><span class="operator">(</span><span class="constructor">S</span><span class="operator">:</span><span class="governing">sig</span> <span class="governing">include</span> <span class="module">REQUIRED</span> <span class="governing">type</span> <span class="type">state</span> <span class="governing">end</span><span class="operator">)</span> <span class="operator">=</span> <span class="governing">struct</span>
      <span class="governing">open </span><span class="module">S</span>
    
      <span class="governing">module</span> <span class="module">M</span> <span class="operator">=</span> <span class="governing">struct</span>
        <span class="governing">type</span> <span class="type">'a m</span> <span class="operator">=</span> state <span class="operator">-&gt;</span> 'a <span class="operator">*</span> state
        <span class="governing">let</span> <span class="operator">(</span> <span class="operator">&gt;&gt;=</span> <span class="operator">)</span> <span class="operator">(</span>a<span class="operator">:</span><span class="type">'a m</span><span class="operator">)</span> <span class="operator">(</span>ab<span class="operator">:</span><span class="type">'a </span><span class="operator">-&gt;</span><span class="type"> 'b m</span><span class="operator">)</span> <span class="operator">:</span> 'b m <span class="operator">=</span> 
          <span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span>
          a s <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">a</span><span class="operator">,</span><span class="variable-name">s</span><span class="operator">)</span> <span class="operator">-&gt;</span> 
          ab a s
        <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> <span class="operator">(</span> <span class="operator">&gt;&gt;=</span> <span class="operator">)</span>
        <span class="governing">let</span> <span class="function-name">return</span><span class="variable-name"> a</span> <span class="operator">=</span> <span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span> <span class="operator">(</span>a<span class="operator">,</span>s<span class="operator">)</span>
      <span class="governing">end</span>
      <span class="governing">open </span><span class="module">M</span>
    
      <span class="doc">(** Main Earley routine, parameterized *)</span>
      <span class="governing">let</span> <span class="function-name">_earley</span><span class="variable-name"> 
          </span><span class="operator">~(</span><span class="variable-name">expand_nt</span><span class="operator">:</span><span class="type">nt</span><span class="operator">*</span><span class="type">int</span><span class="operator">-&gt;</span><span class="type">unit m</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">~(</span><span class="variable-name">expand_tm</span><span class="operator">:</span><span class="type">tm</span><span class="operator">*</span><span class="type">int</span><span class="operator">-&gt;</span><span class="type">unit m</span><span class="operator">)</span><span class="variable-name"> 
          </span><span class="operator">~</span><span class="variable-name">incr_count
          </span><span class="operator">~(</span><span class="variable-name">get_blocked_items</span><span class="operator">:</span><span class="type">int</span><span class="operator">*</span><span class="type">sym</span><span class="operator">-&gt;</span><span class="type">nt_item list m</span><span class="operator">)</span><span class="variable-name">
          </span><span class="operator">~(</span><span class="variable-name">get_complete_items</span><span class="operator">:</span><span class="type">int</span><span class="operator">*</span><span class="type">sym </span><span class="operator">-&gt;</span><span class="type"> int list m</span><span class="operator">)</span><span class="variable-name">
          </span><span class="operator">~(</span><span class="variable-name">add_item</span><span class="operator">:</span><span class="type">item </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="variable-name">
          </span><span class="operator">~(</span><span class="variable-name">add_items</span><span class="operator">:</span><span class="type">item list </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="variable-name">
          </span><span class="operator">~(</span><span class="variable-name">pop_todo</span><span class="operator">:</span><span class="type"> unit</span><span class="operator">-&gt;</span><span class="type"> item option m</span><span class="operator">)</span><span class="variable-name">
          </span><span class="operator">~(</span><span class="variable-name">note_blocked_cuts</span><span class="operator">:</span><span class="type"> nt_item </span><span class="operator">-&gt;</span><span class="type"> int list </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="variable-name">
          </span><span class="operator">~(</span><span class="variable-name">note_complete_cuts</span><span class="operator">:</span><span class="type"> nt_item list </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span>
        <span class="operator">=</span> 
    
        <span class="governing">let</span> <span class="variable-name">mark</span> <span class="operator">=</span> <span class="operator">!</span>spec_mark_ref <span class="governing">in</span>
    
        <span class="comment-delimiter">(* </span><span class="comment">process a blocked item </span><span class="comment-delimiter">*)</span>
        <span class="governing">let</span> <span class="function-name">cut_blocked_item</span> <span class="operator">=</span> <span class="keyword">fun</span> <span class="variable-name">itm</span> <span class="operator">-&gt;</span> 
          <span class="governing">let</span> <span class="variable-name">k_</span><span class="operator">,</span><span class="variable-name">_S</span> <span class="operator">=</span> <span class="operator">(</span>itm<span class="operator">|&gt;</span>dot_k<span class="operator">,</span>itm<span class="operator">|&gt;</span>dot_bs<span class="operator">|&gt;</span>syms_hd<span class="operator">)</span> <span class="governing">in</span>
          mark <span class="string">&quot;am&quot;</span><span class="operator">;</span>
          get_complete_items <span class="operator">(</span>k_<span class="operator">,</span>_S<span class="operator">)</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">js</span> <span class="operator">-&gt;</span>
          mark <span class="string">&quot;ap&quot;</span><span class="operator">;</span>
          note_blocked_cuts itm js <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span>
          js <span class="operator">|&gt;</span> <span class="module">List.</span>map <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">j</span> <span class="operator">-&gt;</span> <span class="constructor">Nt_item</span> <span class="operator">(</span>cut itm j<span class="operator">))</span>
          <span class="operator">|&gt;</span> add_items <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
          mark <span class="string">&quot;as&quot;</span><span class="operator">;</span>
          return <span class="operator">()</span>              
        <span class="governing">in</span>
    
        <span class="comment-delimiter">(* </span><span class="comment">process a complete item </span><span class="comment-delimiter">*)</span>
        <span class="governing">let</span> <span class="variable-name">cut_complete_item</span> <span class="operator">=</span>
          <span class="keyword">fun</span> <span class="operator">{</span>i_<span class="operator">;</span>sym<span class="operator">;</span>j_<span class="operator">}</span> <span class="operator">-&gt;</span> 
            mark <span class="string">&quot;bm&quot;</span><span class="operator">;</span>
            get_blocked_items <span class="operator">(</span>i_<span class="operator">,</span>sym<span class="operator">)</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">itms</span> <span class="operator">-&gt;</span>
            mark <span class="string">&quot;bp&quot;</span><span class="operator">;</span>
            note_complete_cuts itms j_ <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span>
            itms <span class="operator">|&gt;</span> <span class="module">List.</span>map <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">itm</span> <span class="operator">-&gt;</span> <span class="constructor">Nt_item</span> <span class="operator">(</span>cut itm j_<span class="operator">))</span>
            <span class="operator">|&gt;</span> add_items <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span>
            mark <span class="string">&quot;bs&quot;</span><span class="operator">;</span>
            return <span class="operator">()</span>
        <span class="governing">in</span>
    
        <span class="comment-delimiter">(* </span><span class="comment">process an item </span><span class="comment-delimiter">*)</span>
        <span class="governing">let</span> <span class="function-name">step</span><span class="variable-name"> itm</span> <span class="operator">=</span>
          mark <span class="string">&quot;em&quot;</span><span class="operator">;</span>
          <span class="keyword">match</span> itm <span class="keyword">with</span> 
          <span class="operator">|</span> <span class="constructor">Nt_item</span> itm <span class="operator">-&gt;</span> <span class="operator">(</span>
              incr_count<span class="operator">()</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span> 
              <span class="governing">let</span> <span class="variable-name">bs</span> <span class="operator">=</span> itm<span class="operator">|&gt;</span>dot_bs <span class="governing">in</span>
              <span class="keyword">match</span> bs<span class="operator">|&gt;</span>syms_nil <span class="keyword">with</span>
              <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> 
                <span class="comment-delimiter">(* </span><span class="comment">item is complete </span><span class="comment-delimiter">*)</span>
                <span class="governing">let</span> <span class="variable-name">itm</span> <span class="operator">=</span> <span class="constructor">Sym_item</span> <span class="operator">{</span>sym<span class="operator">=</span>_NT <span class="operator">(</span>itm<span class="operator">|&gt;</span>dot_nt<span class="operator">);</span> i_<span class="operator">=(</span>itm<span class="operator">|&gt;</span>dot_i<span class="operator">);</span> j_<span class="operator">=(</span>itm<span class="operator">|&gt;</span>dot_k<span class="operator">)}</span> <span class="governing">in</span>
                add_item itm <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span>
                mark <span class="string">&quot;ep&quot;</span><span class="operator">;</span>
                return <span class="operator">()</span>
              <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
                  <span class="governing">let</span> <span class="variable-name">_S</span><span class="operator">,</span><span class="variable-name">bs</span> <span class="operator">=</span> syms_hd bs<span class="operator">,</span> syms_tl bs <span class="governing">in</span>
                  <span class="comment-delimiter">(* </span><span class="comment">we need to record that we need to expand _S </span><span class="comment-delimiter">*)</span>
                  mark <span class="string">&quot;er&quot;</span><span class="operator">;</span>
                  add_item <span class="operator">(</span><span class="constructor">Sym_at_k</span> <span class="operator">{</span> sym<span class="operator">=</span>_S<span class="operator">;</span> k_<span class="operator">=(</span>itm<span class="operator">|&gt;</span>dot_k<span class="operator">)})</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span>
                  mark <span class="string">&quot;eu&quot;</span><span class="operator">;</span>
                  <span class="comment-delimiter">(* </span><span class="comment">and we need to process the item against complete items </span><span class="comment-delimiter">*)</span>
                  cut_blocked_item itm <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
                  mark <span class="string">&quot;ev&quot;</span><span class="operator">;</span>
                  return <span class="operator">()))</span>
          <span class="operator">|</span> <span class="constructor">Sym_item</span> itm <span class="operator">-&gt;</span> <span class="operator">(</span>
              cut_complete_item itm <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
              mark <span class="string">&quot;ga&quot;</span><span class="operator">;</span>
              return <span class="operator">())</span>
          <span class="operator">|</span> <span class="constructor">Sym_at_k</span> <span class="operator">{</span>sym<span class="operator">;</span>k_<span class="operator">}</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
              <span class="keyword">match</span> is_nt sym <span class="keyword">with</span>
              <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> expand_nt <span class="operator">(</span>dest_nt sym<span class="operator">,</span>k_<span class="operator">)</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span> mark <span class="string">&quot;ha&quot;</span><span class="operator">;</span> return <span class="operator">()</span>
              <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> expand_tm <span class="operator">(</span>dest_tm sym<span class="operator">,</span>k_<span class="operator">)</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="operator">()</span> <span class="operator">-&gt;</span> mark <span class="string">&quot;hb&quot;</span><span class="operator">;</span> return <span class="operator">())</span>        
        <span class="governing">in</span>
    
        <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> step <span class="governing">in</span>
    
        <span class="comment-delimiter">(* </span><span class="comment">loop until no items left to process </span><span class="comment-delimiter">*)</span>
        <span class="governing">let</span> <span class="governing">rec</span> <span class="function-name">loop</span><span class="variable-name"> </span><span class="operator">()</span> <span class="operator">=</span> 
          pop_todo <span class="operator">()</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">function</span>
          <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> return <span class="operator">()</span>
          <span class="operator">|</span> <span class="constructor">Some</span> itm <span class="operator">-&gt;</span> step itm <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span> loop <span class="operator">()</span>
        <span class="governing">in</span>
        loop <span class="operator">()</span>
    
      <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">:</span><span class="type">
        </span><span class="label">expand_nt</span><span class="operator">:(</span><span class="type">nt </span><span class="operator">*</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">expand_tm</span><span class="operator">:(</span><span class="type">tm </span><span class="operator">*</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">incr_count</span><span class="operator">:(</span><span class="type">unit </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">get_blocked_items</span><span class="operator">:(</span><span class="type">int </span><span class="operator">*</span><span class="type"> sym </span><span class="operator">-&gt;</span><span class="type"> nt_item list m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">get_complete_items</span><span class="operator">:(</span><span class="type">int </span><span class="operator">*</span><span class="type"> sym </span><span class="operator">-&gt;</span><span class="type"> int list m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">add_item</span><span class="operator">:(</span><span class="type">item </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">add_items</span><span class="operator">:(</span><span class="type">item list </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">pop_todo</span><span class="operator">:(</span><span class="type">unit </span><span class="operator">-&gt;</span><span class="type"> item option m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> 
        </span><span class="label">note_blocked_cuts</span><span class="operator">:(</span><span class="type">nt_item </span><span class="operator">-&gt;</span><span class="type"> int list </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">note_complete_cuts</span><span class="operator">:(</span><span class="type">nt_item list </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        unit m
        </span><span class="operator">=</span> _earley
    
      <span class="doc">(** expand_... are in the monad; adjust the types of expand_nt and
         expand_tm so that they return a list of items and a list of ints
         *)</span>
      <span class="governing">let</span> <span class="function-name">earley</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">expand_nt </span><span class="operator">~</span><span class="variable-name">expand_tm </span><span class="operator">~</span><span class="variable-name">add_items</span> <span class="operator">=</span>
        <span class="governing">let</span> <span class="function-name">expand_nt</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">nt</span><span class="operator">,</span><span class="variable-name">i</span><span class="operator">)</span> <span class="operator">=</span> 
          add_items <span class="operator">(</span>expand_nt <span class="operator">(</span>nt<span class="operator">,</span>i<span class="operator">)</span> <span class="operator">|&gt;</span> <span class="module">List.</span>map <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">itm</span> <span class="operator">-&gt;</span> <span class="constructor">Nt_item</span> itm<span class="operator">))</span>
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="function-name">expand_tm</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">tm</span><span class="operator">,</span><span class="variable-name">i_</span><span class="operator">)</span> <span class="operator">=</span>
          expand_tm <span class="operator">(</span>tm<span class="operator">,</span>i_<span class="operator">)</span> 
          <span class="operator">|&gt;</span> <span class="module">List.</span>map <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">j_</span> <span class="operator">-&gt;</span> <span class="operator">(</span><span class="constructor">Sym_item</span><span class="operator">{</span>i_<span class="operator">;</span>sym<span class="operator">=</span>_TM tm<span class="operator">;</span>j_<span class="operator">}))</span>
          <span class="operator">|&gt;</span> add_items
        <span class="governing">in</span>
        _earley <span class="operator">~</span>expand_nt <span class="operator">~</span>expand_tm <span class="operator">~</span>add_items
    
      <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">:</span> <span class="type">
        </span><span class="label">expand_nt</span><span class="operator">:(</span><span class="type">nt </span><span class="operator">*</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> nt_item list</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">expand_tm</span><span class="operator">:(</span><span class="type">tm </span><span class="operator">*</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> int list</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">add_items</span><span class="operator">:(</span><span class="type">item list </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">incr_count</span><span class="operator">:(</span><span class="type">unit </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">get_blocked_items</span><span class="operator">:(</span><span class="type">int </span><span class="operator">*</span><span class="type"> sym </span><span class="operator">-&gt;</span><span class="type"> nt_item list m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">get_complete_items</span><span class="operator">:(</span><span class="type">int </span><span class="operator">*</span><span class="type"> sym </span><span class="operator">-&gt;</span><span class="type"> int list m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">add_item</span><span class="operator">:(</span><span class="type">item </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">pop_todo</span><span class="operator">:(</span><span class="type">unit </span><span class="operator">-&gt;</span><span class="type"> item option m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> 
        </span><span class="label">note_blocked_cuts</span><span class="operator">:(</span><span class="type">nt_item </span><span class="operator">-&gt;</span><span class="type"> int list </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">note_complete_cuts</span><span class="operator">:(</span><span class="type">nt_item list </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> unit m</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        unit m </span><span class="operator">=</span> earley
    
    <span class="governing">end</span>
    
    <span class="doc">(** Refine the state type; for the spec, we use an extremely
       inefficient state type (for which the implementation of the util
       functions are hopefully correct); see {!Earley_unstaged} for an
       efficient version *)</span>
    <span class="governing">module</span> <span class="module">Internal_with_inefficient_spec_state</span><span class="operator">(</span><span class="variable-name">Req</span><span class="operator">:</span><span class="type">REQUIRED</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">=</span> <span class="governing">struct</span>
      <span class="governing">open </span><span class="module">Req</span>
    
      <span class="governing">module</span> <span class="module">State_type</span> <span class="operator">=</span> <span class="governing">struct</span>
    
        <span class="comment-delimiter">(* </span><span class="comment">todo_done is really a set; we add items to todo providing they
           are not already in todo_done </span><span class="comment-delimiter">*)</span>
        <span class="governing">type</span> <span class="type">state</span> <span class="operator">=</span> <span class="operator">{</span>
          count<span class="operator">:</span>int<span class="operator">;</span>
          <span class="keyword">mutable</span> todo<span class="operator">:</span> item list<span class="operator">;</span>
          todo_done<span class="operator">:(</span>item<span class="operator">,</span>unit<span class="operator">)</span> <span class="module">Hashtbl.</span>t
        <span class="operator">}</span>
        <span class="governing">let</span> <span class="variable-name">empty_state</span> <span class="operator">=</span> <span class="operator">{</span> count<span class="operator">=</span>0<span class="operator">;</span> todo<span class="operator">=[];</span> todo_done<span class="operator">=</span><span class="module">Hashtbl.</span>create 100 <span class="operator">}</span>
      <span class="governing">end</span>
      <span class="governing">open </span><span class="module">State_type</span>
    
      <span class="governing">module</span> <span class="module">Internal</span><span class="operator">=</span><span class="module">Internal</span><span class="operator">(</span><span class="governing">struct</span> <span class="governing">include</span> <span class="module">Req</span> <span class="governing">include</span> <span class="module">State_type</span> <span class="governing">end</span><span class="operator">)</span>
      <span class="governing">open </span><span class="module">Internal</span>
    
      <span class="doc">(** The (executable) specification of parsing. Returns a list of
          items (FIXME?). Implementations such as Earley should return an
          identical set of items (for nt_items at least). NOTE that the
          parameters are independent of the input (in that the input is not
          present as an argument). *)</span>
      <span class="governing">let</span> <span class="function-name">earley_spec</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">expand_nt </span><span class="operator">~</span><span class="variable-name">expand_tm</span> <span class="operator">=</span> 
        <span class="governing">let</span> <span class="function-name">incr_count</span><span class="variable-name"> </span><span class="operator">()</span><span class="variable-name"> s</span> <span class="operator">=</span> <span class="operator">(),{</span>s <span class="keyword">with</span> count<span class="operator">=</span>s.count<span class="operator">+</span>1<span class="operator">}</span> <span class="governing">in</span>
        <span class="governing">let</span> <span class="function-name">get_blocked_items</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">k</span><span class="operator">,</span><span class="variable-name">_S</span><span class="operator">)</span><span class="variable-name"> s</span> <span class="operator">=</span> 
          <span class="governing">let</span> <span class="variable-name">blocked</span> <span class="operator">=</span> <span class="builtin">ref</span> <span class="operator">[]</span> <span class="governing">in</span>
          s.todo_done <span class="operator">|&gt;</span> <span class="module">Hashtbl.</span>iter <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">itm _</span> <span class="operator">-&gt;</span>
              <span class="keyword">match</span> itm <span class="keyword">with</span> 
              <span class="operator">|</span> <span class="constructor">Nt_item</span> itm <span class="operator">-&gt;</span> <span class="operator">(</span>
                <span class="governing">let</span> <span class="variable-name">k_</span><span class="operator">,</span><span class="variable-name">bs</span> <span class="operator">=</span> itm<span class="operator">|&gt;</span>dot_k<span class="operator">,</span>itm<span class="operator">|&gt;</span>dot_bs <span class="governing">in</span>
                <span class="keyword">match</span> k_<span class="operator">=</span>k <span class="operator">&amp;&amp;</span> <span class="operator">not</span> <span class="operator">(</span>syms_nil bs<span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span>syms_hd bs<span class="operator">=</span>_S<span class="operator">)</span> <span class="keyword">with</span>
                <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> <span class="operator">(</span>blocked<span class="operator">:=</span>itm<span class="operator">::!</span>blocked<span class="operator">)</span>
                <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> <span class="operator">())</span>
              <span class="operator">|</span> _ <span class="operator">-&gt;</span> <span class="operator">());</span>
          <span class="operator">!</span>blocked<span class="operator">,</span>s
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="function-name">get_complete_items</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">k</span><span class="operator">,</span><span class="variable-name">_S</span><span class="operator">)</span><span class="variable-name"> s</span> <span class="operator">=</span> 
          <span class="governing">let</span> <span class="variable-name">complete</span> <span class="operator">=</span> <span class="builtin">ref</span> <span class="operator">[]</span> <span class="governing">in</span>
          s.todo_done <span class="operator">|&gt;</span> <span class="module">Hashtbl.</span>iter <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">itm _</span> <span class="operator">-&gt;</span>
              <span class="keyword">match</span> itm <span class="keyword">with</span> 
              <span class="operator">|</span> <span class="constructor">Sym_item</span> <span class="operator">{</span>i_<span class="operator">;</span>sym<span class="operator">;</span>j_<span class="operator">}</span> <span class="keyword">when</span> <span class="operator">(</span>i_<span class="operator">=</span>k <span class="operator">&amp;&amp;</span> sym<span class="operator">=</span>_S<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
                  complete<span class="operator">:=</span>j_<span class="operator">::!</span>complete<span class="operator">)</span>
              <span class="operator">|</span> _ <span class="operator">-&gt;</span> <span class="operator">());</span>
          <span class="operator">!</span>complete<span class="operator">,</span>s
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="function-name">_add_item</span><span class="variable-name"> itm s</span> <span class="operator">=</span>
          <span class="keyword">match</span> <span class="module">Hashtbl.</span>mem s.todo_done itm <span class="keyword">with</span>
          <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> <span class="operator">()</span>
          <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> 
            <span class="module">Hashtbl.</span>add s.todo_done itm <span class="operator">();</span>
            s.todo<span class="operator">&lt;-</span>itm<span class="operator">::</span>s.todo<span class="operator">;</span>        
            <span class="operator">()</span>
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="function-name">add_items</span><span class="variable-name"> itms s</span> <span class="operator">=</span> 
          itms <span class="operator">|&gt;</span> <span class="module">List.</span>iter <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">itm</span> <span class="operator">-&gt;</span> _add_item itm s<span class="operator">);</span>
          <span class="operator">(),</span>s
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="function-name">add_item</span><span class="variable-name"> itm s</span> <span class="operator">=</span> 
          _add_item itm s<span class="operator">;</span>
          <span class="operator">(),</span>s        
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="function-name">pop_todo</span><span class="variable-name"> </span><span class="operator">()</span><span class="variable-name"> s</span> <span class="operator">=</span> <span class="keyword">match</span> s.todo <span class="keyword">with</span>
          <span class="operator">|</span> <span class="operator">[]</span> <span class="operator">-&gt;</span> <span class="constructor">None</span><span class="operator">,</span>s
          <span class="operator">|</span> x<span class="operator">::</span>todo <span class="operator">-&gt;</span> <span class="constructor">Some</span> x<span class="operator">,{</span>s <span class="keyword">with</span> todo<span class="operator">}</span>
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="function-name">note_blocked_cuts</span><span class="variable-name"> itm js s</span> <span class="operator">=</span> <span class="operator">(),</span>s <span class="governing">in</span>
        <span class="governing">let</span> <span class="function-name">note_complete_cuts</span><span class="variable-name"> itms j s</span> <span class="operator">=</span> <span class="operator">(),</span>s <span class="governing">in</span>
        <span class="keyword">fun</span> <span class="label">~initial_nt</span><span class="operator">:(</span><span class="label">nt</span><span class="operator">:</span><span class="module">Req.</span><span class="type">nt</span><span class="operator">)</span> <span class="operator">-&gt;</span>
          <span class="operator">{</span> empty_state <span class="keyword">with</span> todo<span class="operator">=(</span>expand_nt <span class="operator">(</span>nt<span class="operator">,</span>0<span class="operator">)|&gt;</span><span class="module">List.</span>map <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> <span class="constructor">Nt_item</span> x<span class="operator">))</span> <span class="operator">}</span>
          <span class="operator">|&gt;</span> earley
            <span class="operator">~</span>expand_nt <span class="operator">~</span>expand_tm <span class="operator">~</span>incr_count <span class="operator">~</span>get_blocked_items <span class="operator">~</span>get_complete_items
            <span class="operator">~</span>add_item <span class="operator">~</span>add_items <span class="operator">~</span>pop_todo
            <span class="operator">~</span>note_blocked_cuts <span class="operator">~</span>note_complete_cuts
          <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">((),</span><span class="variable-name">s</span><span class="operator">)</span> <span class="operator">-&gt;</span> 
          <span class="governing">let</span> <span class="variable-name">complete_items</span> <span class="operator">=</span> 
            <span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">i</span><span class="operator">,</span><span class="variable-name">_S</span><span class="operator">)</span> <span class="operator">-&gt;</span> 
              get_complete_items <span class="operator">(</span>i<span class="operator">,</span>_S<span class="operator">)</span> s <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">n</span><span class="operator">,</span><span class="variable-name">_</span><span class="operator">)</span> <span class="operator">-&gt;</span> n
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="variable-name">items</span> <span class="operator">=</span> <span class="keyword">lazy</span> <span class="governing">begin</span>
            s.todo_done 
            <span class="operator">|&gt;</span> <span class="module">Hashtbl.</span>to_seq_keys
            <span class="operator">|&gt;</span> <span class="module">List.</span>of_seq
          <span class="governing">end</span>
          <span class="governing">in</span>
          <span class="operator">{</span> count<span class="operator">=</span>s.count<span class="operator">;</span>items<span class="operator">;</span>complete_items<span class="operator">;</span> debug<span class="operator">=()</span> <span class="operator">}</span>
    
      <span class="comment-delimiter">(* </span><span class="comment">This exposes the nt_item type to the user; might prefer to use rhs list </span><span class="comment-delimiter">*)</span>
      <span class="governing">let</span> <span class="variable-name">earley_spec</span> <span class="operator">:</span> <span class="type">
        </span><span class="label">expand_nt</span><span class="operator">:(</span><span class="type">nt </span><span class="operator">*</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> </span><span class="module">Req.</span><span class="type">nt_item list</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
        </span><span class="label">expand_tm</span><span class="operator">:(</span><span class="type">tm </span><span class="operator">*</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> int list</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> 
        </span><span class="label">initial_nt</span><span class="operator">:</span><span class="type">nt </span><span class="operator">-&gt;</span><span class="type"> </span><span class="operator">(</span><span class="type">'b</span><span class="operator">,</span><span class="type">'c</span><span class="operator">,</span><span class="type">'d</span><span class="operator">)</span><span class="type"> parse_result
        </span><span class="operator">=</span> earley_spec
    
    <span class="governing">end</span>
    
    
    
    <span class="doc">(** An example parse function which is polymorphic over symbols; no
       functors involved. *)</span>
    <span class="governing">module</span> <span class="module">Internal_example_parse_function</span> <span class="operator">=</span> <span class="governing">struct</span>
      
      <span class="doc">(** An (executable) parsing specification polymorphic over
          nonterminals and terminals *)</span>
      <span class="governing">let</span> <span class="function-name">earley_spec</span><span class="variable-name"> </span><span class="operator">(</span><span class="keyword">type</span><span class="variable-name"> </span><span class="type">nt</span><span class="variable-name"> </span><span class="type">tm</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">expand_nt </span><span class="operator">~(</span><span class="variable-name">expand_tm</span><span class="operator">:</span><span class="type">tm</span><span class="operator">*</span><span class="type">int </span><span class="operator">-&gt;</span><span class="type"> int list</span><span class="operator">)</span>  <span class="operator">=</span>
        <span class="governing">let</span> <span class="governing">module</span> <span class="module">A</span> <span class="operator">=</span> <span class="governing">struct</span>
          <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">nt</span> <span class="operator">=</span> nt
          <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">tm</span> <span class="operator">=</span> tm      
          <span class="governing">include</span> <span class="module">Prelude.Simple_items</span><span class="operator">(</span><span class="governing">struct</span> 
              <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">nt</span> <span class="operator">=</span> nt
              <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">tm</span> <span class="operator">=</span> tm
            <span class="governing">end</span><span class="operator">)</span>
          <span class="governing">include</span> <span class="module">Make_extra_items</span><span class="operator">(</span><span class="governing">struct</span>
              <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">sym</span> <span class="operator">=</span> sym
              <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">nt_item</span> <span class="operator">=</span> nt_item
            <span class="governing">end</span><span class="operator">)</span>
        <span class="governing">end</span>
        <span class="governing">in</span>
        <span class="governing">let</span> <span class="governing">open </span><span class="module">A</span> <span class="governing">in</span>
        <span class="governing">let</span> <span class="governing">module</span> <span class="module">B</span> <span class="operator">=</span> <span class="module">Internal_with_inefficient_spec_state</span><span class="operator">(</span><span class="module">A</span><span class="operator">)</span> <span class="governing">in</span>
        <span class="comment-delimiter">(* </span><span class="comment">let open B in </span><span class="comment-delimiter">*)</span>
        <span class="comment-delimiter">(* </span><span class="comment">let sym_to_sym = function `Nt nt -&gt; Nt nt | `Tm tm -&gt; Tm tm in </span><span class="comment-delimiter">*)</span>
        <span class="comment-delimiter">(* </span><span class="comment">let sym_to_sym = function Nt nt -&gt; `Nt nt | Tm tm -&gt; `Tm tm in  </span><span class="comment-delimiter">*)</span>
        <span class="governing">let</span> <span class="function-name">expand_nt</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">nt</span><span class="operator">,</span><span class="variable-name">i</span><span class="operator">)</span> <span class="operator">=</span> 
          expand_nt nt <span class="operator">|&gt;</span> <span class="module">List.</span>map <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">bs</span> <span class="operator">-&gt;</span>
              <span class="comment-delimiter">(* </span><span class="comment">bs |&gt; List.map sym_to_sym |&gt; fun bs -&gt; </span><span class="comment-delimiter">*)</span>
              <span class="operator">{</span>nt<span class="operator">;</span>i_<span class="operator">=</span>i<span class="operator">;</span>k_<span class="operator">=</span>i<span class="operator">;</span>bs<span class="operator">})</span>
        <span class="governing">in</span>
        <span class="keyword">fun</span> <span class="operator">~</span><span class="variable-name">initial_nt</span> <span class="operator">-&gt;</span>
          <span class="governing">let</span> <span class="variable-name">res</span> <span class="operator">=</span> <span class="module">B.</span>earley_spec <span class="operator">~</span>expand_nt <span class="operator">~</span>expand_tm <span class="operator">~</span>initial_nt <span class="governing">in</span>
          <span class="operator">{</span>res <span class="keyword">with</span> items<span class="operator">=()}</span>  <span class="comment-delimiter">(* </span><span class="comment">can't expose general items </span><span class="comment-delimiter">*)</span>
    <span class="governing">end</span>
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Earley_base</span> <span class="operator">=</span> <span class="governing">struct</span> 
    <span class="doc">(** Internal Earley implementation; see {!Earley_simple} for the
        external usable version.
    
        This is the main (internal) Earley implementation, based on
       processing items at index k in the input, before moving to
       k+1. This version of the code tries to assume as little as possible
       about the representation of the underlying structures.  *)</span>
    
    <span class="governing">open </span><span class="module">Prelude</span>
    
    
    <span class="doc">(** What is required by the [Make] functor *)</span> 
    <span class="governing">module</span> <span class="governing">type</span> <span class="module">REQUIRED_BY_BASE</span> <span class="operator">=</span> <span class="governing">sig</span>
    
      <span class="governing">type</span> <span class="type">i_t</span> <span class="operator">=</span> int  
      <span class="governing">type</span> <span class="type">k_t</span> <span class="operator">=</span> int
      <span class="governing">type</span> <span class="type">j_t</span> <span class="operator">=</span> int
    
      <span class="governing">type</span> <span class="type">nt</span>
      <span class="governing">type</span> <span class="type">tm</span>
      <span class="governing">type</span> <span class="type">sym</span>
    
      <span class="governing">val</span> <span class="function-name">sym_case</span><span class="operator">:</span> <span class="label">nt</span><span class="operator">:(</span>nt <span class="operator">-&gt;</span> 'a<span class="operator">)</span> <span class="operator">-&gt;</span> <span class="label">tm</span><span class="operator">:(</span>tm <span class="operator">-&gt;</span> 'a<span class="operator">)</span> <span class="operator">-&gt;</span> sym <span class="operator">-&gt;</span> 'a
      <span class="governing">val</span> <span class="function-name">_NT</span><span class="operator">:</span> nt <span class="operator">-&gt;</span> sym
      <span class="governing">val</span> <span class="function-name">_TM</span><span class="operator">:</span> tm <span class="operator">-&gt;</span> sym
    
      <span class="governing">type</span> <span class="type">nt_item</span>  
      <span class="governing">val</span> <span class="function-name">dot_nt</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> nt
      <span class="governing">val</span> <span class="function-name">dot_i</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> i_t
      <span class="governing">val</span> <span class="function-name">dot_k</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> k_t
      <span class="governing">val</span> <span class="function-name">dot_bs</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> sym list
      <span class="governing">val</span> <span class="function-name">cut</span><span class="operator">:</span> nt_item <span class="operator">-&gt;</span> j_t <span class="operator">-&gt;</span> nt_item
      <span class="governing">val</span> <span class="function-name">mk_nt_item</span> <span class="operator">:</span> nt <span class="operator">-&gt;</span> int <span class="operator">-&gt;</span> sym list <span class="operator">-&gt;</span> nt_item
    
      <span class="governing">type</span> <span class="type">nt_item_set</span>
      <span class="governing">val</span> <span class="function-name">empty_nt_item_set</span><span class="operator">:</span> nt_item_set
      <span class="governing">val</span> <span class="function-name">elements</span> <span class="operator">:</span> nt_item_set <span class="operator">-&gt;</span> nt_item list
      <span class="governing">val</span> <span class="function-name">nt_item_set_of_list</span><span class="operator">:</span> nt_item list <span class="operator">-&gt;</span> nt_item_set
    
      <span class="doc">(** int -&gt; bitms_at_k  FIXME implement as hashtbl *)</span>
      <span class="governing">type</span> <span class="type">bitms_lt_k</span>  
    
      <span class="comment-delimiter">(* </span><span class="comment">int -&gt; nt_item_set </span><span class="comment-delimiter">*)</span>
      <span class="governing">type</span> <span class="type">todo_gt_k</span> 
    
    
      <span class="doc">(** NOTE following are per k *)</span>
    
      <span class="doc">(** nt -&gt; nt_item_set *)</span>
      <span class="governing">type</span> <span class="type">bitms_at_k</span> 
    
      <span class="doc">(** (int*nt) set *)</span>
      <span class="governing">type</span> <span class="type">ixk_done</span>  
    
      <span class="doc">(** tm -&gt; j list option *)</span>
      <span class="governing">type</span> <span class="type">ktjs</span>  
    
    
      <span class="governing">val</span> <span class="function-name">todo_gt_k_find</span><span class="operator">:</span> int <span class="operator">-&gt;</span> todo_gt_k <span class="operator">-&gt;</span> nt_item_set
      <span class="governing">val</span> <span class="function-name">update_bitms_lt_k</span><span class="operator">:</span> int <span class="operator">-&gt;</span> bitms_at_k <span class="operator">-&gt;</span> bitms_lt_k <span class="operator">-&gt;</span> bitms_lt_k <span class="comment-delimiter">(* </span><span class="comment">FIXME what for? </span><span class="comment-delimiter">*)</span>
    
      <span class="governing">val</span> <span class="function-name">empty_todo_gt_k</span><span class="operator">:</span> todo_gt_k
      <span class="governing">val</span> <span class="function-name">empty_bitms_lt_k</span><span class="operator">:</span> bitms_lt_k
      <span class="governing">val</span> <span class="function-name">empty_bitms_at_k</span><span class="operator">:</span> bitms_at_k
      <span class="governing">val</span> <span class="function-name">empty_ixk_done</span><span class="operator">:</span> ixk_done
      <span class="governing">val</span> <span class="function-name">empty_ktjs</span><span class="operator">:</span> ktjs
    
    <span class="governing">end</span>  <span class="comment-delimiter">(* </span><span class="comment">REQUIRED_BY_BASE </span><span class="comment-delimiter">*)</span>
    
    
    <span class="doc">(** Construct the Earley parsing implementation *)</span>
    <span class="governing">module</span> <span class="module">Make</span><span class="operator">(</span><span class="variable-name">A</span><span class="operator">:</span><span class="type">REQUIRED_BY_BASE</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">=</span> <span class="governing">struct</span>
    
      <span class="doc">(** {2 Provided by user} *)</span>
    
      <span class="comment-delimiter">(* </span><span class="comment">to make doc self-contained </span><span class="comment-delimiter">*)</span>
      <span class="governing">include</span> <span class="module">A</span>
    
      <span class="doc">(** {2 Content of Make proper starts here} *)</span>
    
      <span class="governing">type</span> <span class="type">state</span> <span class="operator">=</span> <span class="operator">{</span>
        count<span class="operator">:</span> int<span class="operator">;</span>
        todo<span class="operator">:</span> nt_item list<span class="operator">;</span>
        todo_done<span class="operator">:</span> nt_item_set<span class="operator">;</span>
        todo_gt_k<span class="operator">:</span> todo_gt_k<span class="operator">;</span>
        bitms_lt_k<span class="operator">:</span> bitms_lt_k<span class="operator">;</span>
        bitms_at_k<span class="operator">:</span> bitms_at_k<span class="operator">;</span>
        ixk_done<span class="operator">:</span> ixk_done<span class="operator">;</span>
        ktjs<span class="operator">:</span>ktjs<span class="operator">;</span>
        <span class="comment-delimiter">(* </span><span class="comment">cuts:cuts </span><span class="comment-delimiter">*)</span>
      <span class="operator">}</span>
    
    
      <span class="governing">let</span> <span class="variable-name">empty_state</span> <span class="operator">=</span> <span class="operator">{</span>
        count<span class="operator">=</span>0<span class="operator">;</span>
        todo<span class="operator">=[];</span>
        todo_done<span class="operator">=</span>empty_nt_item_set<span class="operator">;</span>
        todo_gt_k<span class="operator">=</span>empty_todo_gt_k<span class="operator">;</span>
        bitms_lt_k<span class="operator">=</span>empty_bitms_lt_k<span class="operator">;</span>
        bitms_at_k<span class="operator">=</span>empty_bitms_at_k<span class="operator">;</span>
        ixk_done<span class="operator">=</span>empty_ixk_done<span class="operator">;</span>
        ktjs<span class="operator">=</span>empty_ktjs<span class="operator">;</span>
        <span class="comment-delimiter">(* </span><span class="comment">cuts=empty_cuts </span><span class="comment-delimiter">*)</span>
      <span class="operator">}</span>
        
    
      <span class="governing">type</span> <span class="type">'a m</span> <span class="operator">=</span> state <span class="operator">-&gt;</span> 'a <span class="operator">*</span> state
      <span class="governing">let</span> <span class="operator">(</span> <span class="operator">&gt;&gt;=</span> <span class="operator">)</span> <span class="operator">(</span>a<span class="operator">:</span><span class="type">'a m</span><span class="operator">)</span> <span class="operator">(</span>ab<span class="operator">:</span><span class="type">'a </span><span class="operator">-&gt;</span><span class="type"> 'b m</span><span class="operator">)</span> <span class="operator">:</span> 'b m <span class="operator">=</span> 
        <span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span>
          a s <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">a</span><span class="operator">,</span><span class="variable-name">s</span><span class="operator">)</span> <span class="operator">-&gt;</span> 
          ab a s
      <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> <span class="operator">(</span> <span class="operator">&gt;&gt;=</span> <span class="operator">)</span>
      <span class="governing">let</span> <span class="function-name">return</span><span class="variable-name"> a</span> <span class="operator">=</span> <span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span> <span class="operator">(</span>a<span class="operator">,</span>s<span class="operator">)</span>
    
    
      <span class="comment-delimiter">(* </span><span class="comment">FIXME these expose the state type via _ m </span><span class="comment-delimiter">*)</span>
      <span class="doc">(** 
         - pop_todo can be implemented directly
         - get_bitms_at_k needs bitms_at_k, and a way to map nt_item_set to list (which we have: elements)
         - add_bitm_at_k is fine
         - add_todos_at_k is fine
         - add_todos_gt_k is fine
         - rest are fine
    
         NOTE if we use a mutable impl of state, we can avoid having to
         lookup via nt, update set, and update via nt
      *)</span>
      <span class="governing">type</span> <span class="type">atomic_operations</span> <span class="operator">=</span> <span class="operator">{</span>
        pop_todo<span class="operator">:</span> unit <span class="operator">-&gt;</span> nt_item option m<span class="operator">;</span>
        <span class="comment-delimiter">(* </span><span class="comment">FIXME this op is already known now we know 'a m </span><span class="comment-delimiter">*)</span>
    
        get_bitms_at_k<span class="operator">:</span> nt <span class="operator">-&gt;</span> nt_item list m<span class="operator">;</span>  <span class="comment-delimiter">(* </span><span class="comment">or set? </span><span class="comment-delimiter">*)</span>
        get_bitms_lt_k<span class="operator">:</span> int <span class="operator">*</span> nt <span class="operator">-&gt;</span> nt_item list m<span class="operator">;</span>  <span class="comment-delimiter">(* </span><span class="comment">or set? </span><span class="comment-delimiter">*)</span>
        add_bitm_at_k<span class="operator">:</span> nt_item <span class="operator">-&gt;</span> nt <span class="operator">-&gt;</span> unit m<span class="operator">;</span>  <span class="comment-delimiter">(* </span><span class="comment">FIXME don't need nt </span><span class="comment-delimiter">*)</span>
        <span class="comment-delimiter">(* </span><span class="comment">these three could be implemented as funs t -&gt; t, then lifted to the monad </span><span class="comment-delimiter">*)</span>
    
        add_todos_at_k<span class="operator">:</span> nt_item list <span class="operator">-&gt;</span> unit m<span class="operator">;</span>
        add_todos_gt_k<span class="operator">:</span> nt_item list <span class="operator">-&gt;</span> unit m<span class="operator">;</span>
        <span class="comment-delimiter">(* </span><span class="comment">FIXME these two could be implemented here, since we know the state impl type </span><span class="comment-delimiter">*)</span>
    
        add_ixk_done<span class="operator">:</span> int<span class="operator">*</span>nt <span class="operator">-&gt;</span> unit m<span class="operator">;</span>
        mem_ixk_done<span class="operator">:</span> int<span class="operator">*</span>nt <span class="operator">-&gt;</span> bool m<span class="operator">;</span>
        <span class="comment-delimiter">(* </span><span class="comment">FIXME these, and others, could be implemented outside the monad
           as a funtion t-&gt;t, then injected into the monad now we know
           what 'a m is </span><span class="comment-delimiter">*)</span>
    
        find_ktjs<span class="operator">:</span> tm <span class="operator">-&gt;</span> int list option m<span class="operator">;</span>
        add_ktjs<span class="operator">:</span> tm <span class="operator">-&gt;</span> int list <span class="operator">-&gt;</span> unit m<span class="operator">;</span>
    
        <span class="comment-delimiter">(* </span><span class="comment">record_cuts: (nt_item * int) list -&gt; unit m; </span><span class="comment-delimiter">*)</span>
      <span class="operator">}</span>
    
    
      <span class="doc">(** Hide the following defns from the user *)</span>
      <span class="governing">module</span> <span class="module">Internal2</span> <span class="operator">=</span> <span class="governing">struct</span>
    
        <span class="governing">let</span> <span class="function-name">run_earley</span><span class="variable-name"> </span><span class="comment-delimiter">(*</span><span class="comment">~item_ops</span><span class="comment-delimiter">*)</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">at_ops</span> <span class="operator">=</span> 
          <span class="governing">let</span> <span class="operator">{</span> get_bitms_at_k<span class="operator">;</span> get_bitms_lt_k<span class="operator">;</span> add_bitm_at_k<span class="operator">;</span> pop_todo<span class="operator">;</span>
                add_todos_at_k<span class="operator">;</span> add_todos_gt_k<span class="operator">;</span> add_ixk_done<span class="operator">;</span>
                mem_ixk_done<span class="operator">;</span> find_ktjs<span class="operator">;</span> add_ktjs <span class="operator">}</span> <span class="operator">=</span> at_ops
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="function-name">with_state</span><span class="operator">:</span> <span class="operator">(</span><span class="type">state </span><span class="operator">-&gt;</span><span class="type"> state</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> unit m </span><span class="operator">=</span> <span class="keyword">fun</span> <span class="variable-name">f</span> <span class="operator">-&gt;</span> 
            <span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span> <span class="operator">((),</span>f s<span class="operator">)</span>
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="variable-name">image</span> <span class="operator">=</span> <span class="module">List.</span>map <span class="governing">in</span>
          <span class="governing">let</span> <span class="function-name">is_finished</span><span class="variable-name"> nitm</span> <span class="operator">=</span> nitm<span class="operator">|&gt;</span>dot_bs <span class="operator">=</span> <span class="operator">[]</span> <span class="governing">in</span>
          <span class="governing">let</span> <span class="governing">module</span> <span class="module">Let_syntax</span> <span class="operator">=</span> <span class="governing">struct</span> 
            <span class="governing">let</span> <span class="function-name">bind</span><span class="variable-name"> a </span><span class="operator">~</span><span class="variable-name">f</span> <span class="operator">=</span> a <span class="operator">&gt;&gt;=</span> f 
          <span class="governing">end</span>
          <span class="governing">in</span>
          <span class="keyword">fun</span> <span class="operator">~</span><span class="variable-name">grammar </span><span class="operator">~</span><span class="variable-name">parse_tm </span><span class="operator">~</span><span class="variable-name">input</span> <span class="operator">-&gt;</span>
            <span class="governing">let</span> <span class="variable-name">mark</span> <span class="operator">=</span> <span class="operator">!</span>base_mark_ref <span class="governing">in</span>
            <span class="governing">let</span> <span class="operator">{</span>parse_tm<span class="operator">}=</span>parse_tm <span class="governing">in</span>
            <span class="governing">let</span> <span class="operator">{</span>nt_input_to_rhss<span class="operator">}=</span>grammar <span class="governing">in</span>
            <span class="governing">let</span> <span class="function-name">new_items</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">nt </span><span class="operator">~</span><span class="variable-name">input </span><span class="operator">~</span><span class="variable-name">pos</span> <span class="operator">=</span> 
              nt_input_to_rhss <span class="operator">~</span>nt <span class="operator">~</span>input <span class="operator">~</span>pos <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">rhss</span> <span class="operator">-&gt;</span> 
              rhss <span class="operator">|&gt;</span> <span class="module">List.</span>map <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">rhs</span> <span class="operator">-&gt;</span> 
                  <span class="governing">let</span> <span class="variable-name">rhs</span> <span class="operator">=</span> rhs <span class="operator">|&gt;</span> <span class="module">List.</span>map <span class="operator">(</span><span class="keyword">function</span> <span class="constructor">Nt</span> nt <span class="operator">-&gt;</span> _NT nt <span class="operator">|</span> <span class="constructor">Tm</span> tm <span class="operator">-&gt;</span> _TM tm<span class="operator">)</span> <span class="governing">in</span>
                  mk_nt_item nt pos rhs<span class="operator">)</span>
            <span class="governing">in</span>
            <span class="governing">begin</span>
    
              <span class="comment-delimiter">(* </span><span class="comment">
    
    Explanation of step_at_k code which follows:
    
    The basic Earley step is:
    
    X -&gt; i as k',S bs     k' S k
    ----------------------------
    X -&gt; i as S k bs
    
    In the code, there are labels of the form (*:am:*). The following
    discussion is indexed by these labels
    
    - af: 
      - the item nitm is complete, ie of the form Y -&gt; k',as,k,[]
      - aj,al: has (k',Y,k) been encountered before? if so, do nothing
      - am: if not encountered before, k' Y k is cut with blocked X -&gt;
        ... and new todo items are added
    
    - ax: 
      - item is not complete ie of form _ -&gt; i,as,k,S bs
    
    - ax/ce: 
      - S is nonterm Y
      - add bitm to blocked items at (k,Y)
      - check if we have seen (k,Y) before (bitms_empty)
      - co: if we have, check if k Y k; cut bitm with k Y k if so
      - cw: if we haven't, generate new items from (k,Y)
    
    - ax/ec:
      - S is terminal tm
      - attempt to retrieve (k,tm,j) set from ktjs
      - ek: if we haven't already met (k,tm) then parse (k,tm), update
        ktjs and pass on js
      - otherwise, just reuse js from previously
      - el: given the set of js (which are all &gt;= k)
      - partition into &gt;k, and =k
      - for j &gt; k, cut bitm with j, and add to todos
        - note that if this is the first time we meet (k,tm), then there
          are no other items blocked on (k,tm); if this is not the first
          time, then we have already processed items blocked on (k,tm); in
          either case, we do not need to do anything more with items
          blocked on (k,tm); in fact, we don't even need to record such
          items
      - em: if k is in js (ie tm matched the empty string) cut bitm with k
    
    </span><span class="comment-delimiter">*)</span>
    
              <span class="governing">let</span> <span class="function-name">step_at_k</span><span class="variable-name"> k nitm</span> <span class="operator">=</span> 
                mark <span class="string">&quot;aa&quot;</span><span class="operator">;</span>
                <span class="governing">let</span> <span class="function-name">get_bitms</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">i</span><span class="operator">,</span><span class="variable-name">x</span><span class="operator">)</span> <span class="operator">=</span>
                  <span class="keyword">if</span> i<span class="operator">=</span>k <span class="keyword">then</span> get_bitms_at_k x <span class="keyword">else</span>
                    get_bitms_lt_k <span class="operator">(</span>i<span class="operator">,</span>x<span class="operator">)</span>
                <span class="governing">in</span>
    
                <span class="keyword">match</span> is_finished nitm <span class="keyword">with</span> 
                <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> <span class="operator">(</span>                                                       <span class="comment-delimiter">(*</span><span class="comment">:af:</span><span class="comment-delimiter">*)</span>
                    mark <span class="string">&quot;af&quot;</span><span class="operator">;</span>
                    <span class="governing">let</span> <span class="operator">(</span><span class="variable-name">k'</span><span class="operator">,</span><span class="variable-name">_Y</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span>nitm<span class="operator">|&gt;</span>dot_i<span class="operator">,</span>nitm<span class="operator">|&gt;</span>dot_nt<span class="operator">)</span> <span class="governing">in</span>  
                    <span class="governing">let</span><span class="infix-extension-node">%bind</span> <span class="variable-name">already_done</span> <span class="operator">=</span> mem_ixk_done <span class="operator">(</span>k'<span class="operator">,</span>_Y<span class="operator">)</span> <span class="governing">in</span>               <span class="comment-delimiter">(*</span><span class="comment">:aj:</span><span class="comment-delimiter">*)</span>
                    mark <span class="string">&quot;ak&quot;</span><span class="operator">;</span>
                    <span class="keyword">match</span> already_done <span class="keyword">with</span>     
                    <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> mark <span class="string">&quot;al&quot;</span><span class="operator">;</span> return <span class="operator">()</span>                                <span class="comment-delimiter">(*</span><span class="comment">:al:</span><span class="comment-delimiter">*)</span>
                    <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> <span class="operator">(</span>                                                  <span class="comment-delimiter">(*</span><span class="comment">:am:</span><span class="comment-delimiter">*)</span>
                        mark <span class="string">&quot;am&quot;</span><span class="operator">;</span>                
                        add_ixk_done <span class="operator">(</span>k'<span class="operator">,</span>_Y<span class="operator">)</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>                   
                        mark <span class="string">&quot;ap&quot;</span><span class="operator">;</span>
                        get_bitms <span class="operator">(</span>k'<span class="operator">,</span>_Y<span class="operator">)</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">bitms</span> <span class="operator">-&gt;</span>                  
                        mark <span class="string">&quot;ar&quot;</span><span class="operator">;</span>
                        <span class="comment-delimiter">(* </span><span class="comment">record_cuts (List.map (fun bitm -&gt; (bitm,k)) bitms) &gt;&gt;= fun _ -&gt; </span><span class="comment-delimiter">*)</span>
                        <span class="comment-delimiter">(* </span><span class="comment">mark &quot;as&quot;; </span><span class="comment-delimiter">*)</span>
                        <span class="comment-delimiter">(* </span><span class="comment">NOTE the following image is guaranteed not to
                           contain duplicates... (?) </span><span class="comment-delimiter">*)</span>
                        <span class="governing">let</span> <span class="variable-name">new_todos_at_k</span> <span class="operator">=</span> image <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">bitm</span> <span class="operator">-&gt;</span> cut bitm k<span class="operator">)</span> bitms <span class="governing">in</span>
                        <span class="comment-delimiter">(* </span><span class="comment">Printf.printf &quot;debug: %d %d\n%!&quot; (List.length bitms) (nt_item_set_of_list new_todos_at_k |&gt; elements |&gt; List.length); </span><span class="comment-delimiter">*)</span>
                        mark <span class="string">&quot;at&quot;</span><span class="operator">;</span>
                        add_todos_at_k new_todos_at_k <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
                        mark <span class="string">&quot;au&quot;</span><span class="operator">;</span> return <span class="operator">()))</span>
                <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> <span class="operator">(</span>                                                      <span class="comment-delimiter">(*</span><span class="comment">:ax:</span><span class="comment-delimiter">*)</span>
                    mark <span class="string">&quot;ax&quot;</span><span class="operator">;</span>
                    <span class="governing">let</span> <span class="variable-name">bitm</span> <span class="operator">=</span> nitm <span class="governing">in</span>   
                    <span class="governing">let</span> <span class="variable-name">_S</span> <span class="operator">=</span> <span class="module">List.</span>hd <span class="operator">(</span>bitm<span class="operator">|&gt;</span>dot_bs<span class="operator">)</span> <span class="governing">in</span> 
                    _S <span class="operator">|&gt;</span> sym_case  
                      <span class="label">~nt</span><span class="operator">:(</span><span class="keyword">fun</span> <span class="variable-name">_Y</span> <span class="operator">-&gt;</span>                                              <span class="comment-delimiter">(*</span><span class="comment">:ce:</span><span class="comment-delimiter">*)</span>
                          mark <span class="string">&quot;ce&quot;</span><span class="operator">;</span>
                          get_bitms_at_k _Y <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">bitms</span> <span class="operator">-&gt;</span>     
                          mark <span class="string">&quot;ch&quot;</span><span class="operator">;</span>
                          <span class="governing">let</span> <span class="variable-name">bitms_empty</span> <span class="operator">=</span> bitms<span class="operator">=[]</span> <span class="governing">in</span>     
                          add_bitm_at_k bitm _Y <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>     
                          mark <span class="string">&quot;ck&quot;</span><span class="operator">;</span>
                          <span class="keyword">match</span> bitms_empty <span class="keyword">with</span>  
                          <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> <span class="operator">(</span>                                            <span class="comment-delimiter">(*</span><span class="comment">:co:</span><span class="comment-delimiter">*)</span>
                              mark <span class="string">&quot;co&quot;</span><span class="operator">;</span>
                              mem_ixk_done <span class="operator">(</span>k<span class="operator">,</span>_Y<span class="operator">)</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">function</span>    
                              <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> 
                                <span class="comment-delimiter">(* </span><span class="comment">record_cuts [(bitm,k)] &gt;&gt;= fun _ -&gt; </span><span class="comment-delimiter">*)</span>
                                add_todos_at_k <span class="operator">[</span>cut bitm k<span class="operator">]</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
                                mark <span class="string">&quot;cr&quot;</span><span class="operator">;</span>
                                return <span class="operator">()</span>
                              <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> return <span class="operator">())</span>    
                          <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> <span class="operator">(</span>                                             <span class="comment-delimiter">(*</span><span class="comment">:cw:</span><span class="comment-delimiter">*)</span>
                              mark <span class="string">&quot;cw&quot;</span><span class="operator">;</span>
                              <span class="governing">let</span> <span class="variable-name">itms</span> <span class="operator">=</span> new_items <span class="label">~nt</span><span class="operator">:</span>_Y <span class="operator">~</span>input <span class="label">~pos</span><span class="operator">:</span>k <span class="governing">in</span>
                              add_todos_at_k itms <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
                              mark <span class="string">&quot;cz&quot;</span><span class="operator">;</span>
                              return <span class="operator">()</span>
                            <span class="operator">))</span>  
                      <span class="label">~tm</span><span class="operator">:(</span><span class="keyword">fun</span> <span class="variable-name">tm</span> <span class="operator">-&gt;</span>                                              <span class="comment-delimiter">(*</span><span class="comment">:ec:</span><span class="comment-delimiter">*)</span>
                          mark <span class="string">&quot;ec&quot;</span><span class="operator">;</span>
                          find_ktjs tm <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">ktjs</span> <span class="operator">-&gt;</span>     
                          <span class="operator">(</span><span class="keyword">match</span> ktjs <span class="keyword">with</span>
                           <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
                               <span class="comment-delimiter">(* </span><span class="comment">we need to process kT </span><span class="comment-delimiter">*)</span>                        <span class="comment-delimiter">(*</span><span class="comment">:ek:</span><span class="comment-delimiter">*)</span>
                               <span class="governing">let</span> <span class="variable-name">js</span> <span class="operator">=</span> parse_tm <span class="operator">~</span>tm <span class="operator">~</span>input <span class="label">~pos</span><span class="operator">:</span>k <span class="governing">in</span> 
                               add_ktjs tm js <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>  
                               return js<span class="operator">)</span> 
                           <span class="operator">|</span> <span class="constructor">Some</span> js <span class="operator">-&gt;</span> return js<span class="operator">)</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">js</span> <span class="operator">-&gt;</span> 
                          <span class="comment-delimiter">(* </span><span class="comment">there may be a k in js, in which case we have a 
                             new todo at the current stage </span><span class="comment-delimiter">*)</span>
                          <span class="governing">let</span> <span class="operator">(</span><span class="variable-name">xs</span><span class="operator">,</span><span class="variable-name">js</span><span class="operator">)</span> <span class="operator">=</span> <span class="module">List.</span>partition <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">j</span> <span class="operator">-&gt;</span> j<span class="operator">=</span>k<span class="operator">)</span> js <span class="governing">in</span>       <span class="comment-delimiter">(*</span><span class="comment">:el:</span><span class="comment-delimiter">*)</span>
                          <span class="comment-delimiter">(* </span><span class="comment">record_cuts (List.map (fun j -&gt; (bitm,j)) js) &gt;&gt;= fun _ -&gt;  </span><span class="comment-delimiter">*)</span>
                          add_todos_gt_k <span class="operator">(</span>image <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">j</span> <span class="operator">-&gt;</span> cut bitm j<span class="operator">)</span> js<span class="operator">)</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
                          <span class="keyword">match</span> xs <span class="keyword">with</span>                                           <span class="comment-delimiter">(*</span><span class="comment">:em:</span><span class="comment-delimiter">*)</span>
                          <span class="operator">|</span> <span class="operator">[]</span> <span class="operator">-&gt;</span> return <span class="operator">()</span>     
                          <span class="operator">|</span> _ <span class="operator">-&gt;</span> add_todos_at_k <span class="operator">[</span>cut bitm k<span class="operator">]))</span>
              <span class="governing">in</span> 
    
    
              <span class="comment-delimiter">(* </span><span class="comment">FIXME monad syntax may make this easier to read </span><span class="comment-delimiter">*)</span>
              <span class="governing">let</span> <span class="governing">rec</span> <span class="function-name">loop_at_k</span><span class="variable-name"> k</span> <span class="operator">=</span> 
                <span class="comment-delimiter">(* </span><span class="comment">print_endline &quot;loop_at_k&quot;; </span><span class="comment-delimiter">*)</span>
                pop_todo <span class="operator">()</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">function</span>
                <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> return <span class="operator">()</span>
                <span class="operator">|</span> <span class="constructor">Some</span> itm <span class="operator">-&gt;</span> step_at_k k itm <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span> loop_at_k k
              <span class="governing">in</span>
    
              <span class="governing">let</span> <span class="governing">rec</span> <span class="function-name">loop</span><span class="variable-name"> k</span> <span class="operator">=</span> 
                <span class="comment-delimiter">(* </span><span class="comment">Printf.printf &quot;loop %d\n&quot; k; </span><span class="comment-delimiter">*)</span>
                <span class="keyword">match</span> k <span class="operator">&gt;</span> input.input_length <span class="keyword">with</span>  
                <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> return <span class="operator">()</span>
                <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> 
                  <span class="comment-delimiter">(* </span><span class="comment">process items </span><span class="comment-delimiter">*)</span>
                  loop_at_k k <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
                  <span class="governing">let</span> <span class="variable-name">k'</span> <span class="operator">=</span> k<span class="operator">+</span>1 <span class="governing">in</span>
                  <span class="comment-delimiter">(* </span><span class="comment">
               todo and todo_done are updated with todo_gt_k[k'];
               bitms_lt_k is updated: bitms_lt_k[k]=bitms_at_k
               bitms_at_k is reset;
               ixk_done and ktjs are reset </span><span class="comment-delimiter">*)</span>
                  with_state <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">s</span> <span class="operator">-&gt;</span>
                      <span class="governing">let</span> <span class="variable-name">todo'</span> <span class="operator">=</span> todo_gt_k_find k' s.todo_gt_k <span class="governing">in</span>
                      <span class="governing">let</span> <span class="variable-name">todo</span> <span class="operator">=</span> elements todo' <span class="governing">in</span>
                      <span class="comment-delimiter">(* </span><span class="comment">Printf.printf &quot;elements: %d&quot; (List.length todo); </span><span class="comment-delimiter">*)</span>
                      <span class="operator">{</span> count<span class="operator">=</span>s.count<span class="operator">;</span>
                        todo<span class="operator">;</span>
                        todo_done<span class="operator">=</span>todo'<span class="operator">;</span>
                        todo_gt_k<span class="operator">=</span>s.todo_gt_k<span class="operator">;</span>
                        bitms_lt_k<span class="operator">=(</span>update_bitms_lt_k k s.bitms_at_k s.bitms_lt_k<span class="operator">);</span>
                        bitms_at_k<span class="operator">=</span>empty_bitms_at_k<span class="operator">;</span>
                        ixk_done<span class="operator">=</span>empty_ixk_done<span class="operator">;</span>
                        ktjs<span class="operator">=</span>empty_ktjs<span class="operator">;</span>
                        <span class="comment-delimiter">(* </span><span class="comment">cuts=s.cuts; </span><span class="comment-delimiter">*)</span>
                      <span class="operator">})</span> <span class="operator">&gt;&gt;=</span> <span class="keyword">fun</span> <span class="variable-name">_</span> <span class="operator">-&gt;</span>
                  loop k'
              <span class="governing">in</span>
    
    
              loop 0
            <span class="governing">end</span> <span class="comment-delimiter">(* </span><span class="comment">run_earley </span><span class="comment-delimiter">*)</span>
    
        <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">:</span> <span class="type">
    </span><span class="label">at_ops</span><span class="operator">:</span><span class="type">atomic_operations </span><span class="operator">-&gt;</span><span class="type">
    </span><span class="label">grammar</span><span class="operator">:(</span><span class="type">nt</span><span class="operator">,</span><span class="type"> tm</span><span class="operator">,</span><span class="type"> 'a</span><span class="operator">)</span><span class="type"> input_dependent_grammar </span><span class="operator">-&gt;</span><span class="type">
    </span><span class="label">parse_tm</span><span class="operator">:(</span><span class="type">tm</span><span class="operator">,</span><span class="type"> 'a</span><span class="operator">)</span><span class="type"> terminal_input_matcher </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">input</span><span class="operator">:</span><span class="type">'a input </span><span class="operator">-&gt;</span><span class="type"> unit m
    </span><span class="operator">=</span> run_earley
    
      <span class="governing">end</span>  <span class="comment-delimiter">(* </span><span class="comment">Internal2 </span><span class="comment-delimiter">*)</span>
    
    
      <span class="governing">module</span> <span class="module">Export</span> <span class="operator">:</span> <span class="governing">sig</span>
        
        <span class="doc">(** Abstract type of Earley parsers *)</span>
        <span class="governing">type</span> <span class="type">earley_parser</span>
    
        <span class="doc">(** Construct a generic Earley parser (independent of grammar) *)</span>
        <span class="governing">val</span> <span class="function-name">make_earley_parser</span><span class="operator">:</span> 
          <span class="label">at_ops</span><span class="operator">:</span>atomic_operations <span class="operator">-&gt;</span>
          earley_parser
    
        <span class="doc">(** Execute the Earley parser on a given grammar and
           input. Returns the final state. We don't mind exposing the
           state type because this is an internal library, intended to be
           used eg by {!Earley_simple}. *)</span>
        <span class="governing">val</span> <span class="function-name">run_earley_parser</span><span class="operator">:</span>
          <span class="label">earley_parser</span><span class="operator">:</span>earley_parser <span class="operator">-&gt;</span> 
          <span class="label">grammar</span><span class="operator">:(</span>nt<span class="operator">,</span> tm<span class="operator">,</span> 'a<span class="operator">)</span> input_dependent_grammar <span class="operator">-&gt;</span>
          <span class="label">parse_tm</span><span class="operator">:(</span>tm<span class="operator">,</span> 'a<span class="operator">)</span> terminal_input_matcher <span class="operator">-&gt;</span> 
          <span class="label">input</span><span class="operator">:</span>'a input <span class="operator">-&gt;</span> 
          <span class="label">initial_state</span><span class="operator">:</span>state <span class="operator">-&gt;</span>
          state
      <span class="governing">end</span> <span class="operator">=</span> <span class="governing">struct</span>
        <span class="governing">type</span> <span class="type">earley_parser</span> <span class="operator">=</span> <span class="operator">{</span>
          run_parser<span class="operator">:</span> 
            'a. grammar<span class="operator">:(</span>nt<span class="operator">,</span> tm<span class="operator">,</span> 'a<span class="operator">)</span> input_dependent_grammar <span class="operator">-&gt;</span>
            <span class="label">parse_tm</span><span class="operator">:(</span>tm<span class="operator">,</span> 'a<span class="operator">)</span> terminal_input_matcher <span class="operator">-&gt;</span> 
            <span class="label">input</span><span class="operator">:</span>'a input <span class="operator">-&gt;</span> 
            unit m
        <span class="operator">}</span>
    
        <span class="governing">let</span> <span class="function-name">make_earley_parser</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">at_ops</span> <span class="operator">=</span>
          <span class="operator">{</span>run_parser<span class="operator">=(</span><span class="keyword">fun</span> <span class="operator">~</span><span class="variable-name">grammar </span><span class="operator">~</span><span class="variable-name">parse_tm </span><span class="operator">~</span><span class="variable-name">input</span> <span class="operator">-&gt;</span> 
               <span class="module">Internal2.</span>run_earley <span class="operator">~</span>at_ops <span class="operator">~</span>grammar <span class="operator">~</span>parse_tm <span class="operator">~</span>input<span class="operator">)}</span>
    
        <span class="governing">let</span> <span class="function-name">_run_earley_parser</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">earley_parser </span><span class="operator">~</span><span class="variable-name">grammar </span><span class="operator">~</span><span class="variable-name">parse_tm </span><span class="operator">~</span><span class="variable-name">input</span> <span class="operator">=</span> 
          earley_parser.run_parser <span class="operator">~</span>grammar <span class="operator">~</span>parse_tm <span class="operator">~</span>input
    
        <span class="doc">(**FIXME we can hide the earley_parser type, and just return a
           function that takes grammar_etc...; finally, we can return
           interesting parts of the state separately, so that the
           functionality does not depend on any types we define above *)</span>
        <span class="governing">let</span> <span class="function-name">run_earley_parser</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">earley_parser </span><span class="operator">~</span><span class="variable-name">grammar </span><span class="operator">~</span><span class="variable-name">parse_tm </span><span class="operator">~</span><span class="variable-name">input </span><span class="operator">~</span><span class="variable-name">initial_state</span> <span class="operator">=</span>
          _run_earley_parser <span class="operator">~</span>earley_parser <span class="operator">~</span>grammar <span class="operator">~</span>parse_tm <span class="operator">~</span>input initial_state
          <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">((),</span><span class="variable-name">s</span><span class="operator">)</span> <span class="operator">-&gt;</span> s
      <span class="governing">end</span>
    
      <span class="governing">include</span> <span class="module">Export</span>
    
    <span class="governing">end</span>
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Actions</span> <span class="operator">=</span> <span class="governing">struct</span> 
    <span class="doc">(** Apply actions to the result of an Earley parse *)</span>
    
    
    <span class="governing">module</span> <span class="module">Internal</span><span class="operator">(</span><span class="constructor">T</span><span class="operator">:</span><span class="governing">sig</span>
        <span class="governing">type</span> <span class="type">nt</span>
        <span class="governing">type</span> <span class="type">tm</span>
        <span class="governing">type</span> <span class="type">sym</span>
        <span class="governing">type</span> <span class="type">uni_val</span>
    <span class="governing">end</span><span class="operator">)</span> <span class="operator">=</span> <span class="governing">struct</span>
      
      <span class="governing">open </span><span class="module">T</span>
    
      <span class="doc">(** Apply actions for a given symbol, between two indices. *)</span>
      <span class="governing">let</span> <span class="function-name">apply_actions</span><span class="variable-name"> 
          </span><span class="comment-delimiter">(* </span><span class="comment">(type nt tm sym uni_val) </span><span class="comment-delimiter">*)</span><span class="variable-name">
          </span><span class="operator">~</span><span class="variable-name">is_nt </span><span class="operator">~</span><span class="variable-name">dest_nt </span><span class="operator">~</span><span class="variable-name">dest_tm </span><span class="operator">~</span><span class="variable-name">get_rhss
          </span><span class="operator">~</span><span class="variable-name">cut </span><span class="operator">~</span><span class="variable-name">apply_tm 
          </span><span class="comment-delimiter">(* </span><span class="comment">~nt_to_string </span><span class="comment-delimiter">*)</span>
        <span class="operator">=</span>
        <span class="governing">let</span> <span class="governing">rec</span> <span class="function-name">for_sym</span><span class="variable-name"> </span><span class="operator">~(</span><span class="variable-name">sym</span><span class="operator">:</span><span class="type">sym</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">i </span><span class="operator">~</span><span class="variable-name">j ctxt</span> <span class="operator">=</span>
          <span class="keyword">match</span> is_nt sym <span class="keyword">with</span>
          <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> for_nt <span class="label">~nt</span><span class="operator">:(</span>dest_nt sym<span class="operator">)</span> <span class="operator">~</span>i <span class="operator">~</span>j ctxt
          <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> for_tm <span class="label">~tm</span><span class="operator">:(</span>dest_tm sym<span class="operator">)</span> <span class="operator">~</span>i <span class="operator">~</span>j ctxt
        <span class="governing">and</span> <span class="function-name">for_tm</span><span class="variable-name"> </span><span class="operator">~(</span><span class="variable-name">tm</span><span class="operator">:</span><span class="type">tm</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">i </span><span class="operator">~</span><span class="variable-name">j ctxt</span> <span class="operator">:</span> <span class="type">uni_val option</span> <span class="operator">=</span> 
          <span class="governing">let</span> <span class="variable-name">r</span> <span class="operator">=</span> apply_tm <span class="operator">~</span>tm <span class="operator">~</span>i <span class="operator">~</span>j <span class="governing">in</span>
          <span class="comment-delimiter">(* </span><span class="comment">assert (r&lt;&gt;None);  </span><span class="comment-delimiter">*)</span>
          <span class="comment-delimiter">(* </span><span class="comment">NOTE r may be None in the case that we have a rule like X -&gt;
             &quot;x&quot; and we try to match X to i,i+1, but where input.(i) is
             not x; this happens because we are searching for the first
             rhs that matches; if we knew the rhs directly, we could
             assert that r was never None. FIXME is it worth tracking
             rules by ids during Earley parsing? This would slightly
             complicate the Earley code, but make this code quicker and
             possibly simpler </span><span class="comment-delimiter">*)</span>
          r
        <span class="governing">and</span> <span class="function-name">for_nt</span><span class="variable-name"> </span><span class="operator">~(</span><span class="variable-name">nt</span><span class="operator">:</span><span class="type">nt</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">i </span><span class="operator">~</span><span class="variable-name">j ctxt</span> <span class="operator">:</span> <span class="type">uni_val option</span> <span class="operator">=</span>
          <span class="comment-delimiter">(* </span><span class="comment">(ctxt |&gt; List.map (fun (i,_,j) -&gt; (string_of_int i,string_of_int j) |&gt; fun (x,y) -&gt; x^&quot;,&quot;^y) |&gt; String.concat &quot;;&quot; |&gt; print_endline); </span><span class="comment-delimiter">*)</span>
          <span class="keyword">match</span> <span class="module">List.</span>mem <span class="operator">(</span>i<span class="operator">,</span>nt<span class="operator">,</span>j<span class="operator">)</span> ctxt <span class="keyword">with</span> 
          <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> <span class="constructor">None</span>
          <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> <span class="governing">begin</span>
              <span class="governing">let</span> <span class="variable-name">ctxt</span> <span class="operator">=</span> <span class="operator">(</span>i<span class="operator">,</span>nt<span class="operator">,</span>j<span class="operator">)::(</span>ctxt <span class="operator">|&gt;</span> <span class="module">List.</span>filter <span class="operator">(</span><span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">i'</span><span class="operator">,</span><span class="variable-name">_</span><span class="operator">,</span><span class="variable-name">j'</span><span class="operator">)</span> <span class="operator">-&gt;</span> <span class="operator">(</span>i<span class="operator">,</span>j<span class="operator">)=(</span>i'<span class="operator">,</span>j'<span class="operator">)))</span> <span class="governing">in</span>
              <span class="comment-delimiter">(* </span><span class="comment">get a list (sequence?) of rhs for the nt </span><span class="comment-delimiter">*)</span>
              get_rhss <span class="operator">~</span>nt <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">rhss</span> <span class="operator">-&gt;</span> 
              <span class="comment-delimiter">(* </span><span class="comment">now find the first one that parses i,j exactly </span><span class="comment-delimiter">*)</span>
              rhss <span class="operator">|&gt;</span> <span class="module">Misc.</span>iter_till_some <span class="operator">(</span><span class="keyword">fun</span> <span class="operator">(</span><span class="variable-name">rhs</span><span class="operator">,</span><span class="variable-name">act</span><span class="operator">)</span> <span class="operator">-&gt;</span>
                  for_syms <span class="label">~syms</span><span class="operator">:</span>rhs <span class="operator">~</span>i <span class="operator">~</span>j ctxt <span class="operator">|&gt;</span> <span class="keyword">function</span>
                  <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="constructor">None</span>
                  <span class="operator">|</span> <span class="constructor">Some</span> vs <span class="operator">-&gt;</span> <span class="constructor">Some</span> <span class="operator">(</span>act<span class="operator">(</span>vs<span class="operator">)))</span>
            <span class="governing">end</span>
        <span class="governing">and</span> <span class="function-name">for_syms</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">syms </span><span class="operator">~</span><span class="variable-name">i </span><span class="operator">~</span><span class="variable-name">j ctxt</span> <span class="operator">:</span> <span class="type">uni_val list option</span> <span class="operator">=</span> 
          <span class="keyword">match</span> syms <span class="keyword">with</span>
          <span class="operator">|</span> <span class="operator">[]</span> <span class="operator">-&gt;</span> <span class="constructor">None</span>
          <span class="comment-delimiter">(* </span><span class="comment">NOTE by special casing the [sym] case, we can ensure cut is
             never called with empty syms </span><span class="comment-delimiter">*)</span>
          <span class="operator">|</span> <span class="operator">[</span>sym<span class="operator">]</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
              for_sym <span class="operator">~</span>sym <span class="operator">~</span>i <span class="operator">~</span>j ctxt <span class="operator">|&gt;</span> <span class="keyword">function</span>
              <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="constructor">None</span>
              <span class="operator">|</span> <span class="constructor">Some</span> v <span class="operator">-&gt;</span> <span class="constructor">Some</span><span class="operator">[</span>v<span class="operator">])</span>
          <span class="operator">|</span> sym<span class="operator">::</span>syms <span class="operator">-&gt;</span> 
            <span class="comment-delimiter">(* </span><span class="comment">NOTE cut (E,syms) should not return k=j if there is already
               a parse for i,E,j &quot;in progress&quot; </span><span class="comment-delimiter">*)</span>
            cut <span class="operator">(</span>i<span class="operator">:</span><span class="type">int</span><span class="operator">)</span> <span class="operator">(</span>sym<span class="operator">,</span>syms<span class="operator">)</span> <span class="operator">(</span>j<span class="operator">:</span><span class="type">int</span><span class="operator">)</span> <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">ks</span> <span class="operator">-&gt;</span> 
            ks <span class="operator">|&gt;</span> <span class="module">Misc.</span>iter_till_some <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">k</span> <span class="operator">-&gt;</span> 
                for_sym <span class="operator">~</span>sym <span class="operator">~</span>i <span class="label">~j</span><span class="operator">:</span>k ctxt <span class="operator">|&gt;</span> <span class="keyword">function</span>
                <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="constructor">None</span>
                <span class="operator">|</span> <span class="constructor">Some</span> <span class="operator">(</span>v<span class="operator">:</span><span class="type">uni_val</span><span class="operator">)</span> <span class="operator">-&gt;</span>
                  <span class="comment-delimiter">(* </span><span class="comment">FIXME have to take care if syms is [] </span><span class="comment-delimiter">*)</span>
                  <span class="keyword">assert</span><span class="operator">(</span>syms<span class="operator">&lt;&gt;[]);</span>
                  for_syms <span class="operator">~</span>syms <span class="label">~i</span><span class="operator">:</span>k <span class="operator">~</span>j ctxt <span class="operator">|&gt;</span> <span class="keyword">function</span>
                  <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="constructor">None</span>
                  <span class="operator">|</span> <span class="constructor">Some</span> vs <span class="operator">-&gt;</span> <span class="constructor">Some</span> <span class="operator">(</span>v<span class="operator">::</span>vs<span class="operator">))</span>
        <span class="governing">in</span>
        <span class="operator">(</span>for_nt <span class="operator">:</span><span class="type"> </span><span class="label">nt</span><span class="operator">:</span><span class="type">nt </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">i</span><span class="operator">:</span><span class="type">'a </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">j</span><span class="operator">:</span><span class="type">'a </span><span class="operator">-&gt;</span><span class="type"> </span><span class="operator">(</span><span class="type">int</span><span class="operator">*</span><span class="type">nt</span><span class="operator">*</span><span class="type">int</span><span class="operator">)</span><span class="type"> list </span><span class="operator">-&gt;</span><span class="type"> uni_val option</span><span class="operator">)</span>
    
      <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> apply_actions
    
    
      <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">:</span><span class="type">
    </span><span class="label">is_nt</span><span class="operator">:(</span><span class="type">sym </span><span class="operator">-&gt;</span><span class="type"> bool</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
    </span><span class="label">dest_nt</span><span class="operator">:(</span><span class="type">sym </span><span class="operator">-&gt;</span><span class="type"> nt</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
    </span><span class="label">dest_tm</span><span class="operator">:(</span><span class="type">sym </span><span class="operator">-&gt;</span><span class="type"> tm</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
    </span><span class="label">get_rhss</span><span class="operator">:(</span><span class="type">nt</span><span class="operator">:</span><span class="type">nt </span><span class="operator">-&gt;</span><span class="type"> </span><span class="operator">(</span><span class="type">sym list </span><span class="operator">*</span><span class="type"> </span><span class="operator">(</span><span class="type">uni_val list </span><span class="operator">-&gt;</span><span class="type"> uni_val</span><span class="operator">))</span><span class="type"> list</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
    </span><span class="label">cut</span><span class="operator">:(</span><span class="type">int </span><span class="operator">-&gt;</span><span class="type"> sym </span><span class="operator">*</span><span class="type"> sym list </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> int list</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
    </span><span class="label">apply_tm</span><span class="operator">:(</span><span class="type">tm</span><span class="operator">:</span><span class="type">tm </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">i</span><span class="operator">:</span><span class="type">int </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">j</span><span class="operator">:</span><span class="type">int </span><span class="operator">-&gt;</span><span class="type"> uni_val option</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
    </span><span class="comment-delimiter">(* </span><span class="comment">nt_to_string:'a -&gt; </span><span class="comment-delimiter">*)</span><span class="type">
    nt</span><span class="operator">:</span><span class="type">nt </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">i</span><span class="operator">:</span><span class="type">int </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">j</span><span class="operator">:</span><span class="type">int </span><span class="operator">-&gt;</span><span class="type"> </span><span class="operator">(</span><span class="type">int </span><span class="operator">*</span><span class="type"> nt </span><span class="operator">*</span><span class="type"> int</span><span class="operator">)</span><span class="type"> list </span><span class="operator">-&gt;</span><span class="type"> uni_val option
        </span><span class="operator">=</span> apply_actions
    
      <span class="doc">(** 
    
    So we need:
      - the grammar and actions, in the form of get_rhss
      - the parse results, in the form of cut and apply_tm
        - apply_tm can just return a string, and we can then retrict
          actions to nts only (although this seems like a proper
          restriction for not much extra work)
      - the initial nonterminal S
      - the span i,j  (where S should match i,j exactly, and i is
        presumably 0) 
        - for this we need to be able to call something like max_extent
          (0,S) to get j
    
    *)</span>
      
    
    <span class="governing">end</span>
    
    <span class="doc">(** Apply actions, given various pieces of information about the parse
       (see {!Internal} for further comments). *)</span>
    <span class="governing">let</span> <span class="function-name">apply_actions</span><span class="variable-name"> </span><span class="operator">(</span><span class="keyword">type</span><span class="variable-name"> </span><span class="type">nt</span><span class="variable-name"> tm sym </span><span class="type">uni_val</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">is_nt</span> <span class="operator">=</span> 
      <span class="governing">let</span> <span class="governing">module</span> <span class="module">T</span> <span class="operator">=</span> <span class="governing">struct</span> 
        <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">nt</span> <span class="operator">=</span> nt
        <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">tm</span> <span class="operator">=</span> tm
        <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">sym</span> <span class="operator">=</span> sym 
        <span class="governing">type</span> <span class="governing">nonrec</span> <span class="type">uni_val</span> <span class="operator">=</span> uni_val 
      <span class="governing">end</span>
      <span class="governing">in</span>
      <span class="governing">let</span> <span class="governing">module</span> <span class="module">I</span> <span class="operator">=</span> <span class="module">Internal</span><span class="operator">(</span><span class="module">T</span><span class="operator">)</span> <span class="governing">in</span>
      <span class="module">I.</span>apply_actions <span class="operator">~</span>is_nt
    
    <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> apply_actions
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Earley_simple</span> <span class="operator">=</span> <span class="governing">struct</span> 
    <span class="doc">(** A simple implementation of Earley parsing datastructures, based on
       {!Earley_base}. A more efficient version would not use {!Prelude.Simple_items}. FIXME *)</span>
    
    <span class="governing">open </span><span class="module">Misc</span>
    <span class="governing">open </span><span class="module">Prelude</span>
    
    
    <span class="doc">(** Construct the Earley parsing function.  *)</span>
    <span class="governing">module</span> <span class="module">Make</span><span class="operator">(</span><span class="variable-name">Nt_tm</span><span class="operator">:</span><span class="type">NT_TM</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">=</span> <span class="governing">struct</span>
      <span class="governing">module</span> <span class="module">Internal</span> <span class="operator">=</span> <span class="governing">struct</span>
    
        <span class="governing">module</span> <span class="module">Derived_types</span> <span class="operator">=</span> <span class="governing">struct</span>
          <span class="governing">include</span> <span class="module">Prelude.Simple_items</span><span class="operator">(</span><span class="module">Nt_tm</span><span class="operator">)</span>
        <span class="governing">end</span>
    
        <span class="doc">(** Used to instantiate {!module: Earley_base.Make} *)</span>
        <span class="governing">module</span> <span class="module">Base_requires</span> <span class="operator">=</span> <span class="governing">struct</span>
    
          <span class="governing">type</span> <span class="type">i_t</span> <span class="operator">=</span> int
          <span class="governing">type</span> <span class="type">k_t</span> <span class="operator">=</span> int
          <span class="governing">type</span> <span class="type">j_t</span> <span class="operator">=</span> int
    
          <span class="governing">type</span> <span class="type">tm</span> <span class="operator">=</span> <span class="module">Nt_tm.</span>tm
          <span class="governing">type</span> <span class="type">nt</span> <span class="operator">=</span> <span class="module">Nt_tm.</span>nt
    
          <span class="governing">include</span> <span class="module">Derived_types</span>
    
          <span class="governing">let</span> <span class="function-name">dot_bs_hd</span><span class="variable-name"> nitm</span> <span class="operator">=</span> nitm <span class="operator">|&gt;</span> dot_bs <span class="operator">|&gt;</span> <span class="keyword">function</span>
            <span class="operator">|</span> <span class="operator">[]</span> <span class="operator">-&gt;</span> <span class="constructor">None</span>
            <span class="operator">|</span> x<span class="operator">::</span>xs <span class="operator">-&gt;</span> <span class="constructor">Some</span> x
    
          <span class="comment-delimiter">(* </span><span class="comment">The rest of the code is straightforward </span><span class="comment-delimiter">*)</span>
    
          <span class="governing">module</span> <span class="module">Set_nt_item</span> <span class="operator">=</span> <span class="module">Set.Make</span><span class="operator">(</span><span class="governing">struct</span> 
              <span class="governing">type</span> <span class="type">t</span> <span class="operator">=</span> nt_item 
              <span class="governing">let</span> <span class="variable-name">compare</span> <span class="operator">:</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">=</span><span class="type"> </span><span class="module">Pervasives.</span><span class="type">compare </span><span class="governing">end</span><span class="operator">)</span>
    
          <span class="governing">type</span> <span class="type">ixk</span> <span class="operator">=</span> i_t<span class="operator">*</span>nt
          <span class="governing">module</span> <span class="module">Set_ixk</span> <span class="operator">=</span> <span class="module">Set.Make</span><span class="operator">(</span>
            <span class="governing">struct</span> <span class="governing">type</span> <span class="type">t</span> <span class="operator">=</span> ixk <span class="governing">let</span> <span class="variable-name">compare</span> <span class="operator">:</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">=</span><span class="type"> </span><span class="module">Pervasives.</span><span class="type">compare </span><span class="governing">end</span><span class="operator">)</span>
    
          <span class="governing">module</span> <span class="module">Map_nt</span> <span class="operator">=</span> <span class="module">Map.Make</span><span class="operator">(</span>
            <span class="governing">struct</span> <span class="governing">type</span> <span class="type">t</span> <span class="operator">=</span> nt <span class="governing">let</span> <span class="variable-name">compare</span> <span class="operator">:</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">=</span><span class="type"> </span><span class="module">Pervasives.</span><span class="type">compare </span><span class="governing">end</span><span class="operator">)</span>
          <span class="governing">type</span> <span class="type">'a map_nt</span> <span class="operator">=</span> 'a <span class="module">Map_nt.</span>t
    
          <span class="governing">module</span> <span class="module">Map_int</span> <span class="operator">=</span> <span class="module">Map.Make</span><span class="operator">(</span>
            <span class="governing">struct</span> <span class="governing">type</span> <span class="type">t</span> <span class="operator">=</span> int <span class="governing">let</span> <span class="variable-name">compare</span> <span class="operator">:</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">=</span><span class="type"> </span><span class="module">Pervasives.</span><span class="type">compare </span><span class="governing">end</span><span class="operator">)</span>
          <span class="governing">type</span> <span class="type">'a map_int</span> <span class="operator">=</span> 'a <span class="module">Map_int.</span>t
    
          <span class="governing">module</span> <span class="module">Map_tm</span> <span class="operator">=</span> <span class="module">Map.Make</span><span class="operator">(</span>
            <span class="governing">struct</span> <span class="governing">type</span> <span class="type">t</span> <span class="operator">=</span> tm <span class="governing">let</span> <span class="variable-name">compare</span> <span class="operator">:</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> t </span><span class="operator">-&gt;</span><span class="type"> int </span><span class="operator">=</span><span class="type"> </span><span class="module">Pervasives.</span><span class="type">compare </span><span class="governing">end</span><span class="operator">)</span>
    
          <span class="governing">type</span> <span class="type">nt_item_set</span> <span class="operator">=</span> <span class="module">Set_nt_item.</span>t
          <span class="governing">let</span> <span class="variable-name">elements</span> <span class="operator">=</span> <span class="module">Set_nt_item.</span>elements
          <span class="governing">let</span> <span class="variable-name">empty_nt_item_set</span> <span class="operator">=</span> <span class="module">Set_nt_item.</span>empty
          <span class="governing">let</span> <span class="variable-name">nt_item_set_of_list</span> <span class="operator">=</span> <span class="module">Set_nt_item.</span>of_list
    
          <span class="governing">type</span> <span class="type">bitms_lt_k</span> <span class="operator">=</span> <span class="operator">(</span>nt_item_set map_nt<span class="operator">)</span> map_int
    
          <span class="governing">type</span> <span class="type">todo_gt_k</span> <span class="operator">=</span> nt_item_set map_int
    
          <span class="governing">type</span> <span class="type">bitms_at_k</span> <span class="operator">=</span> nt_item_set map_nt
    
          <span class="governing">type</span> <span class="type">ixk_done</span> <span class="operator">=</span> <span class="module">Set_ixk.</span>t
    
          <span class="governing">type</span> <span class="type">ktjs</span> <span class="operator">=</span> int list <span class="module">Map_tm.</span>t
    
    
          <span class="governing">let</span> <span class="function-name">todo_gt_k_find</span><span class="variable-name"> i t</span> <span class="operator">=</span> 
            <span class="module">Map_int.</span>find_opt i t <span class="operator">|&gt;</span> <span class="keyword">function</span>
            <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="module">Set_nt_item.</span>empty
            <span class="operator">|</span> <span class="constructor">Some</span> set <span class="operator">-&gt;</span> set
    
    
          <span class="governing">let</span> <span class="function-name">update_bitms_lt_k</span><span class="variable-name"> i at_k lt_k</span> <span class="operator">=</span>
            lt_k <span class="operator">|&gt;</span> <span class="module">Map_int.</span>add i at_k
    
    
          <span class="governing">let</span> <span class="variable-name">empty_todo_gt_k</span> <span class="operator">=</span> <span class="module">Map_int.</span>empty
          <span class="governing">let</span> <span class="variable-name">empty_bitms_lt_k</span> <span class="operator">=</span> <span class="module">Map_int.</span>empty
          <span class="governing">let</span> <span class="variable-name">empty_bitms_at_k</span> <span class="operator">=</span> <span class="module">Map_nt.</span>empty
          <span class="governing">let</span> <span class="variable-name">empty_ixk_done</span> <span class="operator">=</span> <span class="module">Set_ixk.</span>empty
          <span class="governing">let</span> <span class="variable-name">empty_ktjs</span> <span class="operator">=</span> <span class="module">Map_tm.</span>empty
    
        <span class="governing">end</span>  <span class="comment-delimiter">(* </span><span class="comment">Base_requires </span><span class="comment-delimiter">*)</span>
    
        <span class="governing">open </span><span class="module">Base_requires</span>
    
        <span class="governing">module</span> <span class="module">Base_impl</span> <span class="operator">=</span> <span class="module">Earley_base.Make</span><span class="operator">(</span><span class="module">Base_requires</span><span class="operator">)</span>
    
        <span class="governing">open </span><span class="module">Base_impl</span>
    
        <span class="governing">let</span> <span class="function-name">pop_todo</span><span class="variable-name"> </span><span class="operator">()</span><span class="variable-name"> s</span> <span class="operator">=</span> <span class="keyword">match</span> s.todo <span class="keyword">with</span>
          <span class="operator">|</span> <span class="operator">[]</span> <span class="operator">-&gt;</span> <span class="constructor">None</span><span class="operator">,</span>s
          <span class="operator">|</span> x<span class="operator">::</span>todo <span class="operator">-&gt;</span> <span class="constructor">Some</span> x<span class="operator">,{</span>s <span class="keyword">with</span> todo<span class="operator">;</span> count<span class="operator">=</span>s.count<span class="operator">+</span>1<span class="operator">}</span>
    
        <span class="governing">let</span> <span class="function-name">_or_empty</span> <span class="operator">=</span> <span class="keyword">function</span>
          <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="module">Set_nt_item.</span>empty
          <span class="operator">|</span> <span class="constructor">Some</span> x <span class="operator">-&gt;</span> x
    
        <span class="governing">let</span> <span class="function-name">get_bitms_at_k</span><span class="variable-name"> nt s</span> <span class="operator">=</span> 
          s.bitms_at_k <span class="operator">|&gt;</span> <span class="module">Map_nt.</span>find_opt nt <span class="operator">|&gt;</span> _or_empty <span class="operator">|&gt;</span> elements
          <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> x<span class="operator">,</span>s
    
        <span class="governing">let</span> <span class="function-name">get_bitms_lt_k</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">i</span><span class="operator">,</span><span class="variable-name">nt</span><span class="operator">)</span><span class="variable-name"> s</span> <span class="operator">=</span>
          s.bitms_lt_k <span class="operator">|&gt;</span> <span class="module">Map_int.</span>find_opt i <span class="operator">|&gt;</span> <span class="operator">(</span><span class="keyword">function</span>
              <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="module">Set_nt_item.</span>empty
              <span class="operator">|</span> <span class="constructor">Some</span> bitms <span class="operator">-&gt;</span> <span class="module">Map_nt.</span>find_opt nt bitms <span class="operator">|&gt;</span> _or_empty<span class="operator">)</span>
          <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> elements x<span class="operator">,</span>s
    
        <span class="governing">let</span> <span class="function-name">add_bitm_at_k</span><span class="variable-name"> itm nt s</span> <span class="operator">=</span>
          s.bitms_at_k <span class="operator">|&gt;</span> <span class="module">Map_nt.</span>find_opt nt <span class="operator">|&gt;</span> _or_empty
          <span class="operator">|&gt;</span> <span class="module">Set_nt_item.</span>add itm <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">itms</span> <span class="operator">-&gt;</span>
          s.bitms_at_k <span class="operator">|&gt;</span> <span class="module">Map_nt.</span>add nt itms <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">bitms_at_k</span> <span class="operator">-&gt;</span>
          <span class="operator">(),{</span>s <span class="keyword">with</span> bitms_at_k<span class="operator">}</span>
    
        <span class="comment-delimiter">(* </span><span class="comment">FIXME this is the one to optimize! </span><span class="comment-delimiter">*)</span>
        <span class="governing">let</span> <span class="function-name">add_todos_at_k</span><span class="variable-name"> itms s</span> <span class="operator">=</span>
          <span class="operator">(</span>itms<span class="operator">,</span>s.todo_done<span class="operator">,</span>s.todo<span class="operator">)</span>
          <span class="operator">|&gt;</span> iter_opt <span class="operator">(</span><span class="keyword">function</span> 
              <span class="operator">|</span> <span class="operator">[],</span>_<span class="operator">,</span>_ <span class="operator">-&gt;</span> <span class="constructor">None</span>
              <span class="operator">|</span> itm<span class="operator">::</span>itms<span class="operator">,</span>todo_done<span class="operator">,</span>todo <span class="operator">-&gt;</span>
                <span class="module">Set_nt_item.</span>mem itm todo_done <span class="operator">|&gt;</span> <span class="keyword">function</span>
                <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> <span class="constructor">Some</span><span class="operator">(</span>itms<span class="operator">,</span>todo_done<span class="operator">,</span>todo<span class="operator">)</span>
                <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span> <span class="constructor">Some</span><span class="operator">(</span>itms<span class="operator">,</span> <span class="module">Set_nt_item.</span>add itm todo_done<span class="operator">,</span>itm<span class="operator">::</span>todo<span class="operator">))</span>
          <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">([],</span><span class="variable-name">todo_done</span><span class="operator">,</span><span class="variable-name">todo</span><span class="operator">)</span> <span class="operator">-&gt;</span> 
          <span class="operator">(),{</span>s <span class="keyword">with</span> todo<span class="operator">;</span> todo_done <span class="operator">}</span>
    
        <span class="governing">let</span> <span class="function-name">add_todos_gt_k</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">itms</span><span class="operator">:</span><span class="type">nt_item list</span><span class="operator">)</span><span class="variable-name"> s</span> <span class="operator">=</span>
          <span class="governing">let</span> <span class="function-name">dot_k</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">x</span><span class="operator">:</span><span class="type">nt_item</span><span class="operator">)</span> <span class="operator">=</span> x.k_ <span class="governing">in</span>  <span class="comment-delimiter">(* </span><span class="comment">some problems with usign .k_ and ocaml not distinguishing based on types... </span><span class="comment-delimiter">*)</span>
          <span class="operator">(</span>itms<span class="operator">,</span>s.todo_gt_k<span class="operator">)</span>
          <span class="operator">|&gt;</span> iter_opt <span class="operator">(</span><span class="keyword">function</span>
              <span class="operator">|</span> <span class="operator">[],</span>_ <span class="operator">-&gt;</span> <span class="constructor">None</span>
              <span class="operator">|</span> itm<span class="operator">::</span>itms<span class="operator">,</span>todo_gt_k <span class="operator">-&gt;</span> 
                <span class="constructor">Some</span><span class="operator">(</span>itms<span class="operator">,</span>
                     todo_gt_k <span class="operator">|&gt;</span> <span class="module">Map_int.</span>find_opt <span class="operator">(</span>dot_k itm<span class="operator">)</span> <span class="operator">|&gt;</span> _or_empty 
                     <span class="operator">|&gt;</span> <span class="module">Set_nt_item.</span>add itm
                     <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">itms</span> <span class="operator">-&gt;</span> <span class="module">Map_int.</span>add <span class="operator">(</span>dot_k itm<span class="operator">)</span> itms todo_gt_k<span class="operator">))</span>
          <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">([],</span><span class="variable-name">todo_gt_k</span><span class="operator">)</span> <span class="operator">-&gt;</span> 
          <span class="operator">(),{</span>s <span class="keyword">with</span> todo_gt_k<span class="operator">}</span>
    
        <span class="governing">let</span> <span class="function-name">add_ixk_done</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">i</span><span class="operator">,</span><span class="variable-name">nt</span><span class="operator">)</span><span class="variable-name"> s</span> <span class="operator">=</span>
          <span class="operator">(),{</span>s <span class="keyword">with</span> ixk_done<span class="operator">=</span>s.ixk_done <span class="operator">|&gt;</span> <span class="module">Set_ixk.</span>add <span class="operator">(</span>i<span class="operator">,</span>nt<span class="operator">)}</span>
    
        <span class="governing">let</span> <span class="function-name">mem_ixk_done</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">i</span><span class="operator">,</span><span class="variable-name">nt</span><span class="operator">)</span><span class="variable-name"> s</span> <span class="operator">=</span> 
          <span class="operator">(</span><span class="module">Set_ixk.</span>mem <span class="operator">(</span>i<span class="operator">,</span>nt<span class="operator">)</span> s.ixk_done<span class="operator">),</span>s
    
        <span class="governing">let</span> <span class="function-name">find_ktjs</span><span class="variable-name"> tm s</span> <span class="operator">=</span> 
          <span class="operator">(</span>s.ktjs <span class="operator">|&gt;</span> <span class="module">Map_tm.</span>find_opt tm<span class="operator">),</span>s
    
        <span class="governing">let</span> <span class="function-name">add_ktjs</span><span class="variable-name"> tm js s</span> <span class="operator">=</span>
          s.ktjs <span class="operator">|&gt;</span> <span class="module">Map_tm.</span>add tm js <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">ktjs</span> <span class="operator">-&gt;</span>
          <span class="operator">(),{</span>s <span class="keyword">with</span> ktjs<span class="operator">}</span>
             
        <span class="governing">let</span> <span class="function-name">run_earley_parser</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">grammar </span><span class="operator">~</span><span class="variable-name">parse_tm </span><span class="operator">~</span><span class="variable-name">input</span> <span class="operator">=</span> 
          <span class="governing">let</span> <span class="variable-name">at_ops</span> <span class="operator">=</span> <span class="operator">{</span> get_bitms_at_k<span class="operator">;</span> get_bitms_lt_k<span class="operator">;</span> add_bitm_at_k<span class="operator">;</span> pop_todo<span class="operator">;</span>
                         add_todos_at_k<span class="operator">;</span> add_todos_gt_k<span class="operator">;</span> add_ixk_done<span class="operator">;</span>
                         mem_ixk_done<span class="operator">;</span> find_ktjs<span class="operator">;</span> add_ktjs <span class="operator">}</span>
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="variable-name">earley_parser</span> <span class="operator">=</span> make_earley_parser <span class="operator">~</span>at_ops <span class="governing">in</span>
          run_earley_parser <span class="operator">~</span>earley_parser <span class="operator">~</span>grammar <span class="operator">~</span>parse_tm <span class="operator">~</span>input
    
        <span class="governing">module</span> <span class="module">Export</span> <span class="operator">:</span> <span class="governing">sig</span> 
          <span class="governing">open </span><span class="module">Nt_tm</span>
          <span class="governing">val</span> <span class="function-name">run_earley_parser</span><span class="operator">:</span> 
            <span class="label">grammar</span><span class="operator">:(</span>nt<span class="operator">,</span> tm<span class="operator">,</span> 'a<span class="operator">)</span> input_dependent_grammar <span class="operator">-&gt;</span>
            <span class="label">parse_tm</span><span class="operator">:(</span>tm<span class="operator">,</span> 'a<span class="operator">)</span> terminal_input_matcher <span class="operator">-&gt;</span>
            <span class="label">input</span><span class="operator">:</span>'a input <span class="operator">-&gt;</span> 
            <span class="label">initial_nt</span><span class="operator">:</span>nt <span class="operator">-&gt;</span> 
            state
        <span class="governing">end</span> <span class="operator">=</span> <span class="governing">struct</span>
          <span class="governing">let</span> <span class="function-name">run_earley_parser</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">grammar </span><span class="operator">~</span><span class="variable-name">parse_tm </span><span class="operator">~</span><span class="variable-name">input </span><span class="label">~initial_nt</span><span class="operator">:</span><span class="variable-name">nt</span> <span class="operator">=</span> 
            <span class="governing">let</span> <span class="variable-name">initial_state</span> <span class="operator">=</span> <span class="operator">{</span> empty_state <span class="keyword">with</span> todo<span class="operator">=[{</span>nt<span class="operator">;</span>i_<span class="operator">=</span>0<span class="operator">;</span>k_<span class="operator">=</span>0<span class="operator">;</span>bs<span class="operator">=[</span><span class="constructor">Nt</span> nt<span class="operator">]}]</span> <span class="operator">}</span> <span class="governing">in</span>
            run_earley_parser <span class="operator">~</span>grammar <span class="operator">~</span>parse_tm <span class="operator">~</span>input <span class="operator">~</span>initial_state 
        <span class="governing">end</span>
    
      <span class="governing">end</span>  <span class="comment-delimiter">(* </span><span class="comment">Internal </span><span class="comment-delimiter">*)</span>
      
      <span class="doc">(** NOTE this exposes the internal types for nt_item, but this is
         just an alias for a type known outside Internal, so we can export
         it. This also exposes the state type FIXME? *)</span>
      <span class="governing">let</span> <span class="variable-name">run_earley_parser</span> <span class="operator">=</span> <span class="module">Internal.Export.</span>run_earley_parser
    <span class="governing">end</span>  <span class="comment-delimiter">(* </span><span class="comment">Make </span><span class="comment-delimiter">*)</span>
    
    
<span class="governing">end</span>

<span class="governing">module</span> <span class="module">Earley_unstaged</span> <span class="operator">=</span> <span class="governing">struct</span> 
    
    <span class="doc">(** Use {!Earley_spec} to produce an efficient O(n^3) parser. *)</span>
    
    <span class="governing">open </span><span class="module">Prelude</span>
    <span class="governing">open </span><span class="module">Misc</span>
    
    
    <span class="doc">(** Construct the parse function. *)</span>
    <span class="governing">module</span> <span class="module">Make</span><span class="operator">(</span><span class="variable-name">Nt_tm</span><span class="operator">:</span><span class="module">Prelude.NT_TM</span><span class="operator">)</span><span class="variable-name"> </span><span class="operator">=</span> <span class="governing">struct</span>
    
      <span class="governing">module</span> <span class="module">Internal</span> <span class="operator">=</span> <span class="governing">struct</span>
    
        
        <span class="governing">module</span> <span class="module">Simple_items</span> <span class="operator">=</span> <span class="module">Prelude.Simple_items</span><span class="operator">(</span><span class="module">Nt_tm</span><span class="operator">)</span>
        <span class="governing">open </span><span class="module">Simple_items</span>
    
        <span class="governing">module</span> <span class="module">Extended_items</span> <span class="operator">=</span> <span class="governing">struct</span> 
          <span class="governing">type</span> <span class="type">sym_item</span> <span class="operator">=</span> <span class="operator">{</span> i_<span class="operator">:</span>int<span class="operator">;</span> sym<span class="operator">:</span>sym<span class="operator">;</span> j_<span class="operator">:</span>int <span class="operator">}</span>
          <span class="governing">type</span> <span class="type">sym_at_k</span> <span class="operator">=</span> <span class="operator">{</span> sym<span class="operator">:</span>sym<span class="operator">;</span> k_<span class="operator">:</span>int <span class="operator">}</span> 
                          
          <span class="governing">type</span> <span class="type">item</span> <span class="operator">=</span> 
            <span class="operator">|</span> <span class="constructor">Nt_item</span> <span class="keyword">of</span> nt_item
            <span class="operator">|</span> <span class="constructor">Sym_item</span> <span class="keyword">of</span> sym_item
            <span class="operator">|</span> <span class="constructor">Sym_at_k</span> <span class="keyword">of</span> sym_at_k
        <span class="governing">end</span>
        <span class="governing">open </span><span class="module">Extended_items</span>
    
        <span class="governing">module</span> <span class="module">State_type</span> <span class="operator">=</span> <span class="governing">struct</span> 
          <span class="comment-delimiter">(* </span><span class="comment">todo_done is really a set; we add items to todo providing they
             are not already in todo_done </span><span class="comment-delimiter">*)</span>
          <span class="governing">type</span> <span class="type">state</span> <span class="operator">=</span> <span class="operator">{</span>
            count<span class="operator">:</span>int<span class="operator">;</span>
            <span class="keyword">mutable</span> todo<span class="operator">:</span>item list<span class="operator">;</span>
            todo_done<span class="operator">:(</span>item<span class="operator">,</span>unit<span class="operator">)</span> <span class="module">Hashtbl.</span>t<span class="operator">;</span>
            blocked<span class="operator">:((</span>int<span class="operator">*</span>sym<span class="operator">),(</span>nt_item<span class="operator">,</span>unit<span class="operator">)</span><span class="module">Hashtbl.</span>t<span class="operator">)</span> <span class="module">Hashtbl.</span>t<span class="operator">;</span>
            <span class="comment-delimiter">(* </span><span class="comment">complete:((int*sym),(int,unit)Hashtbl.t) Hashtbl.t; </span><span class="comment-delimiter">*)</span>
            complete<span class="operator">:((</span>int<span class="operator">*</span>sym<span class="operator">),</span><span class="module">Int_set.</span>t<span class="operator">)</span> <span class="module">Hashtbl.</span>t<span class="operator">;</span>  
            complete2<span class="operator">:</span> <span class="operator">((</span>int <span class="operator">*</span> sym <span class="operator">*</span> sym list<span class="operator">),</span> <span class="module">Int_set.</span>t<span class="operator">)</span> <span class="module">Hashtbl.</span>t
          <span class="operator">}</span>
          <span class="comment-delimiter">(* </span><span class="comment">prefer to use an Int_set for complete so that we interact
             nicely with actions; FIXME now using complete2, so complete
             can revert to using hashtbl </span><span class="comment-delimiter">*)</span>
    
    
          <span class="governing">let</span> <span class="variable-name">empty_state</span> <span class="operator">=</span> <span class="operator">{</span> 
            count<span class="operator">=</span>0<span class="operator">;</span>
            todo<span class="operator">=[];</span> 
            todo_done<span class="operator">=</span><span class="module">Hashtbl.</span>create 100<span class="operator">;</span>
            blocked<span class="operator">=</span><span class="module">Hashtbl.</span>create 100<span class="operator">;</span>
            complete<span class="operator">=</span><span class="module">Hashtbl.</span>create 100<span class="operator">;</span>
            complete2<span class="operator">=</span><span class="module">Hashtbl.</span>create 100
          <span class="operator">}</span>
        <span class="governing">end</span>
        <span class="governing">open </span><span class="module">State_type</span>
    
    
        <span class="governing">module</span> <span class="module">Assembly</span> <span class="operator">=</span> <span class="governing">struct</span> 
          <span class="governing">include</span> <span class="module">Nt_tm</span>
          <span class="governing">include</span> <span class="module">Simple_items</span> 
          <span class="governing">include</span> <span class="module">Extended_items</span> 
          <span class="governing">include</span> <span class="module">State_type</span> 
        <span class="governing">end</span>
    
        <span class="governing">module</span> <span class="module">Earley_spec'</span> <span class="operator">=</span> <span class="module">Earley_spec.Internal</span><span class="operator">(</span><span class="module">Assembly</span><span class="operator">)</span> 
    
        <span class="governing">let</span> <span class="variable-name">earley</span> <span class="operator">=</span> <span class="module">Earley_spec'.</span>earley
    
        <span class="governing">let</span> <span class="function-name">earley</span><span class="variable-name"> </span><span class="operator">~</span><span class="variable-name">expand_nt </span><span class="operator">~</span><span class="variable-name">expand_tm</span> <span class="operator">=</span> 
          <span class="governing">let</span> <span class="function-name">incr_count</span><span class="variable-name"> </span><span class="operator">()</span><span class="variable-name"> s</span> <span class="operator">=</span> <span class="operator">(),{</span>s <span class="keyword">with</span> count<span class="operator">=</span>s.count<span class="operator">+</span>1 <span class="operator">}</span> <span class="governing">in</span>
          <span class="governing">let</span> <span class="function-name">get_blocked_items</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">k</span><span class="operator">,</span><span class="variable-name">_S</span><span class="operator">)</span><span class="variable-name"> s</span> <span class="operator">=</span> 
            <span class="module">Hashtbl.</span>find_opt s.blocked <span class="operator">(</span>k<span class="operator">,</span>_S<span class="operator">)</span> 
            <span class="operator">|&gt;</span> <span class="operator">(</span><span class="keyword">function</span>
                <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="operator">[]</span>
                <span class="operator">|</span> <span class="constructor">Some</span> tbl <span class="operator">-&gt;</span> 
                  <span class="module">Hashtbl.</span>to_seq_keys tbl <span class="operator">|&gt;</span> <span class="module">List.</span>of_seq<span class="operator">)</span>
            <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> x<span class="operator">,</span>s
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="function-name">get_complete_items</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">k</span><span class="operator">,</span><span class="variable-name">_S</span><span class="operator">)</span><span class="variable-name"> s</span> <span class="operator">=</span> 
            <span class="module">Hashtbl.</span>find_opt s.complete <span class="operator">(</span>k<span class="operator">,</span>_S<span class="operator">)</span> 
            <span class="operator">|&gt;</span> <span class="operator">(</span><span class="keyword">function</span>
                <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="operator">[]</span>
                <span class="operator">|</span> <span class="constructor">Some</span> set <span class="operator">-&gt;</span> 
                  <span class="module">Int_set.</span>elements set<span class="operator">)</span>
            <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">x</span> <span class="operator">-&gt;</span> x<span class="operator">,</span>s
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="variable-name">mark</span> <span class="operator">=</span> <span class="operator">!</span>unstaged_mark_ref <span class="governing">in</span>
          <span class="comment-delimiter">(* </span><span class="comment">let mark x = () in </span><span class="comment-delimiter">*)</span>
          <span class="governing">let</span> <span class="function-name">_add_item</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">itm</span><span class="operator">:</span><span class="type">item</span><span class="operator">)</span><span class="variable-name"> s</span> <span class="operator">=</span>
            mark <span class="string">&quot;xa&quot;</span><span class="operator">;</span>
            <span class="governing">let</span> <span class="variable-name">tbl</span> <span class="operator">=</span> s.todo_done <span class="governing">in</span>
            mark <span class="string">&quot;xb&quot;</span><span class="operator">;</span>
            <span class="keyword">match</span> <span class="module">Hashtbl.</span>mem tbl itm <span class="keyword">with</span>
            <span class="operator">|</span> <span class="constant">true</span> <span class="operator">-&gt;</span> mark <span class="string">&quot;xc&quot;</span><span class="operator">;()</span>
            <span class="operator">|</span> <span class="constant">false</span> <span class="operator">-&gt;</span>
              mark <span class="string">&quot;xf&quot;</span><span class="operator">;</span>
              <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> <span class="module">Hashtbl.</span>add tbl itm <span class="operator">()</span> <span class="governing">in</span>
              mark <span class="string">&quot;xg&quot;</span><span class="operator">;</span>
              <span class="comment-delimiter">(* </span><span class="comment">update blocked and complete </span><span class="comment-delimiter">*)</span>
              <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> 
                <span class="keyword">match</span> itm <span class="keyword">with</span> 
                <span class="operator">|</span> <span class="constructor">Nt_item</span> <span class="operator">{</span>nt<span class="operator">;</span>i_<span class="operator">;</span>k_<span class="operator">;</span>bs<span class="operator">=</span>_S<span class="operator">::</span>bs<span class="operator">}</span> <span class="operator">-&gt;</span>
                  <span class="governing">let</span> <span class="variable-name">tbl</span> <span class="operator">=</span> 
                    <span class="module">Hashtbl.</span>find_opt s.blocked <span class="operator">(</span>k_<span class="operator">,</span>_S<span class="operator">)</span> <span class="operator">|&gt;</span> <span class="keyword">function</span>
                    <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
                        <span class="module">Hashtbl.</span>create 100 <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="variable-name">tbl</span> <span class="operator">-&gt;</span>
                        <span class="module">Hashtbl.</span>add s.blocked <span class="operator">(</span>k_<span class="operator">,</span>_S<span class="operator">)</span> tbl<span class="operator">;</span>
                        tbl<span class="operator">)</span>
                    <span class="operator">|</span> <span class="constructor">Some</span> tbl <span class="operator">-&gt;</span> tbl
                  <span class="governing">in</span>
                  <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> <span class="module">Hashtbl.</span>add tbl <span class="operator">{</span>nt<span class="operator">;</span>i_<span class="operator">;</span>k_<span class="operator">;</span>bs<span class="operator">=</span>_S<span class="operator">::</span>bs<span class="operator">}</span> <span class="operator">()</span> <span class="governing">in</span>
                  <span class="operator">()</span>
                <span class="operator">|</span> <span class="constructor">Sym_item</span><span class="operator">{</span>i_<span class="operator">;</span>sym<span class="operator">=</span>_S<span class="operator">;</span>j_<span class="operator">}</span> <span class="operator">-&gt;</span> 
                  <span class="governing">let</span> <span class="variable-name">set</span> <span class="operator">=</span> 
                    <span class="module">Hashtbl.</span>find_opt s.complete <span class="operator">(</span>i_<span class="operator">,</span>_S<span class="operator">)</span> <span class="operator">|&gt;</span> <span class="keyword">function</span>
                    <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="module">Int_set.</span>empty
                    <span class="operator">|</span> <span class="constructor">Some</span> set <span class="operator">-&gt;</span> set
                  <span class="governing">in</span>
                  <span class="module">Hashtbl.</span>replace s.complete <span class="operator">(</span>i_<span class="operator">,</span>_S<span class="operator">)</span> <span class="operator">(</span><span class="module">Int_set.</span>add j_ set<span class="operator">);</span>
                  <span class="operator">()</span>
                <span class="operator">|</span> _ <span class="operator">-&gt;</span> <span class="operator">()</span>
              <span class="governing">in</span>
              mark <span class="string">&quot;xw&quot;</span><span class="operator">;</span>
              <span class="governing">let</span> <span class="variable-name">_</span> <span class="operator">=</span> s.todo<span class="operator">&lt;-</span>itm<span class="operator">::</span>s.todo <span class="governing">in</span>
              mark <span class="string">&quot;xy&quot;</span><span class="operator">;</span>
              <span class="operator">()</span>
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="function-name">add_items</span><span class="variable-name"> itms s</span> <span class="operator">=</span> 
            itms <span class="operator">|&gt;</span> <span class="module">List.</span>iter <span class="operator">(</span><span class="keyword">fun</span> <span class="variable-name">itm</span> <span class="operator">-&gt;</span> _add_item itm s<span class="operator">);</span>
            <span class="operator">(),</span>s
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="function-name">add_item</span><span class="variable-name"> itm s</span> <span class="operator">=</span> 
            _add_item itm s<span class="operator">;</span>
            <span class="operator">(),</span>s        
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="function-name">pop_todo</span><span class="variable-name"> </span><span class="operator">()</span><span class="variable-name"> s</span> <span class="operator">=</span> <span class="keyword">match</span> s.todo <span class="keyword">with</span>
            <span class="operator">|</span> <span class="operator">[]</span> <span class="operator">-&gt;</span> <span class="constructor">None</span><span class="operator">,</span>s
            <span class="operator">|</span> x<span class="operator">::</span>todo <span class="operator">-&gt;</span> <span class="constructor">Some</span> x<span class="operator">,{</span>s <span class="keyword">with</span> todo<span class="operator">}</span>
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="function-name">note_blocked_cuts</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">itm</span><span class="operator">:</span><span class="type">nt_item</span><span class="operator">)</span><span class="variable-name"> js s</span> <span class="operator">=</span> 
            <span class="keyword">match</span> itm <span class="keyword">with</span> 
            <span class="operator">|</span> <span class="operator">{</span>nt<span class="operator">;</span>i_<span class="operator">;</span>k_<span class="operator">;</span>bs<span class="operator">=</span>_S<span class="operator">::</span>bs<span class="operator">}</span> <span class="operator">-&gt;</span> <span class="operator">(</span>
                <span class="governing">let</span> <span class="variable-name">set</span> <span class="operator">=</span> 
                  <span class="module">Hashtbl.</span>find_opt s.complete2 <span class="operator">(</span>k_<span class="operator">,</span>_S<span class="operator">,</span>bs<span class="operator">)</span> <span class="operator">|&gt;</span> <span class="keyword">function</span>
                  <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="module">Int_set.</span>empty
                  <span class="operator">|</span> <span class="constructor">Some</span> s <span class="operator">-&gt;</span> s
                <span class="governing">in</span>
                <span class="governing">let</span> <span class="variable-name">set'</span> <span class="operator">=</span> <span class="module">Int_set.</span>union <span class="operator">(</span><span class="module">Int_set.</span>of_list js<span class="operator">)</span> set <span class="governing">in</span>
                <span class="module">Hashtbl.</span>replace s.complete2 <span class="operator">(</span>k_<span class="operator">,</span>_S<span class="operator">,</span>bs<span class="operator">)</span> set'<span class="operator">;</span>
                <span class="operator">(),</span>s<span class="operator">)</span>
            <span class="operator">|</span> _ <span class="operator">-&gt;</span> <span class="builtin">failwith</span> <span class="string">&quot;impossible&quot;</span>
          <span class="governing">in</span>
          <span class="governing">let</span> <span class="function-name">note_complete_cuts</span><span class="variable-name"> itms j s</span> <span class="operator">=</span> 
            itms <span class="operator">|&gt;</span> <span class="module">List.</span>iter <span class="operator">(</span><span class="keyword">fun</span> <span class="operator">{</span>nt<span class="operator">;</span>i_<span class="operator">;</span>k_<span class="operator">;</span>bs<span class="operator">=</span>_S<span class="operator">::</span>bs<span class="operator">}</span> <span class="operator">-&gt;</span> 
                <span class="governing">let</span> <span class="variable-name">set</span> <span class="operator">=</span>
                  <span class="module">Hashtbl.</span>find_opt s.complete2 <span class="operator">(</span>k_<span class="operator">,</span>_S<span class="operator">,</span>bs<span class="operator">)</span> <span class="operator">|&gt;</span> <span class="keyword">function</span>
                  <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="module">Int_set.</span>empty
                  <span class="operator">|</span> <span class="constructor">Some</span> s <span class="operator">-&gt;</span> s
                <span class="governing">in</span>
                <span class="governing">let</span> <span class="variable-name">set'</span> <span class="operator">=</span> <span class="module">Int_set.</span>add j set <span class="governing">in</span>
                <span class="module">Hashtbl.</span>replace s.complete2 <span class="operator">(</span>k_<span class="operator">,</span>_S<span class="operator">,</span>bs<span class="operator">)</span> set'<span class="operator">);</span>
            <span class="operator">(),</span>s
          <span class="governing">in</span>          
          <span class="keyword">fun</span> <span class="label">~initial_nt</span><span class="operator">:</span><span class="variable-name">nt</span> <span class="operator">-&gt;</span>
            <span class="operator">{</span> empty_state <span class="keyword">with</span> todo<span class="operator">=[</span><span class="constructor">Nt_item</span><span class="operator">{</span>nt<span class="operator">;</span>i_<span class="operator">=</span>0<span class="operator">;</span>k_<span class="operator">=</span>0<span class="operator">;</span>bs<span class="operator">=[</span><span class="constructor">Nt</span> nt<span class="operator">]}]</span> <span class="operator">}</span>
            <span class="operator">|&gt;</span> earley
              <span class="operator">~</span>expand_nt <span class="operator">~</span>expand_tm <span class="operator">~</span>incr_count <span class="operator">~</span>get_blocked_items <span class="operator">~</span>get_complete_items
              <span class="operator">~</span>add_item <span class="operator">~</span>add_items <span class="operator">~</span>pop_todo
              <span class="operator">~</span>note_blocked_cuts <span class="operator">~</span>note_complete_cuts
            <span class="operator">|&gt;</span> <span class="keyword">fun</span> <span class="operator">((),</span><span class="variable-name">s</span><span class="operator">)</span> <span class="operator">-&gt;</span> 
            <span class="governing">let</span> <span class="variable-name">items</span> <span class="operator">=</span> <span class="keyword">lazy</span> <span class="operator">(</span>
                s.todo_done 
                <span class="operator">|&gt;</span> <span class="module">Hashtbl.</span>to_seq_keys
                <span class="operator">|&gt;</span> <span class="module">List.</span>of_seq<span class="operator">)</span> 
            <span class="governing">in</span>
            <span class="comment-delimiter">(* </span><span class="comment">let get_complete_items_as_set s (k,_S) = Hashtbl.find_opt s.complete (k,_S) in </span><span class="comment-delimiter">*)</span>
            <span class="comment-delimiter">(* </span><span class="comment">let complete_items = get_complete_items_as_set s in </span><span class="comment-delimiter">*)</span>
            <span class="governing">let</span> <span class="function-name">complete_items</span><span class="variable-name"> </span><span class="operator">(</span><span class="variable-name">i</span><span class="operator">,</span><span class="variable-name">_S</span><span class="operator">,</span><span class="variable-name">bs</span><span class="operator">)</span> <span class="operator">=</span> 
              <span class="module">Hashtbl.</span>find_opt s.complete2 <span class="operator">(</span>i<span class="operator">,</span>_S<span class="operator">,</span>bs<span class="operator">)</span> <span class="operator">|&gt;</span> <span class="keyword">function</span>
              <span class="operator">|</span> <span class="constructor">None</span> <span class="operator">-&gt;</span> <span class="module">Int_set.</span>empty
              <span class="operator">|</span> <span class="constructor">Some</span> set <span class="operator">-&gt;</span> set
            <span class="governing">in</span>
            <span class="operator">{</span> count<span class="operator">=</span>s.count<span class="operator">;</span>items<span class="operator">;</span>complete_items<span class="operator">;</span>debug<span class="operator">=</span>s.complete2 <span class="operator">}</span>
            <span class="comment-delimiter">(* </span><span class="comment">s.todo_done |&gt; Hashtbl.to_seq_keys |&gt; List.of_seq </span><span class="comment-delimiter">*)</span>
    
      <span class="governing">end</span> <span class="comment-delimiter">(* </span><span class="comment">Internal </span><span class="comment-delimiter">*)</span>
    
      <span class="governing">open </span><span class="module">Nt_tm</span>
      <span class="governing">let</span> <span class="variable-name">earley_unstaged</span> <span class="operator">:</span> <span class="type">
    </span><span class="label">expand_nt</span><span class="operator">:(</span><span class="type">nt </span><span class="operator">*</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> 'nt_item list</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type">
    </span><span class="label">expand_tm</span><span class="operator">:(</span><span class="type">tm </span><span class="operator">*</span><span class="type"> int </span><span class="operator">-&gt;</span><span class="type"> int list</span><span class="operator">)</span><span class="type"> </span><span class="operator">-&gt;</span><span class="type"> </span><span class="label">initial_nt</span><span class="operator">:</span><span class="type">nt </span><span class="operator">-&gt;</span><span class="type"> </span><span class="operator">(</span><span class="type">'b</span><span class="operator">,</span><span class="type">'c</span><span class="operator">,</span><span class="type">'d</span><span class="operator">)</span><span class="type">parse_result
        </span><span class="operator">=</span> <span class="module">Internal.</span>earley
    
    <span class="governing">end</span>
<span class="governing">end</span>

</pre>

 </body>
</html>
