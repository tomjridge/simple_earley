
= Simple Earley Parsing
:source-highlighter: prettify
:stem: latexmath
Author: Tom Ridge

An implementation of an Earley-like algorithm, designed for
simplicity.

== Meta

On github, to preview the README.html file, try https://htmlpreview.github.io/?https://raw.githubusercontent.com/tomjridge/simple_earley/master/README.html

This document explains the OCaml code for a minimal implementation of
an Earley-like parsing algorithm. The code is reproduced at the bottom
of this document, and is generated by (essentially) concatenating the
two files `src/e_common.ml` and `src/e_cn.ml`. 

References to the code are of the form (l:bc) corresponding to a code
comment `(* l:bc *)` (i.e. a label `bc`).

We assume familiarity with Earley's algorithm.

== Building

To build the code, you need the nix package manager: https://nixos.org/nix/

Then, in the project root directory, type: `nix-shell` to drop to a
bash shell with all the dependencies installed. Then type `make`. You
should end up with various executables that you can run (the files
ending `.native`).

== An Earley-like algorithm

Earley's algorithm works with items of the form latexmath:[( X \rightarrow \alpha . \beta, i, k)] where:

* latexmath:[X] is a nonterminal (nt)
* latexmath:[\alpha] and latexmath:[\beta] are sequences of symbols
* latexmath:[i] and latexmath:[k] are indexes into the input; latexmath:[i \le k]

Notation: latexmath:[i,j,k] are typically integer indexes where latexmath:[i \le k
\le j]; latexmath:[\alpha] and latexmath:[\beta] are typically sequences of symbols;
latexmath:[X,Y,Z,nt] are nonterminals; latexmath:[S,sym] are symbols, latexmath:[T,tm] are
terminals. latexmath:[( X \rightarrow {}_{i} \alpha {}_{k} . \beta)] is an alternative notation to the
usual latexmath:[( X \rightarrow \alpha . \beta, i, k)]. Sometimes we use spaces instead of
commas in items. Sometimes we typeset using verbatim rather than latex
math. 


At (l:bc) the type of `nt_item` (nonterminal item) is given, which is
as expected. N.B. the latexmath:[\alpha] are stored in "reverse" order, that is, an
item latexmath:[( X \rightarrow {}_{i} A B C {}_{k} . U V W)] is stored as
`(X,[C,B,A],[U,V,W],i,k)`. At (l:ba) the type of `tm_item` is
given. This is not standard. A terminal item is of the form latexmath:[( {}_{k} T_{?})]
and corresponds to an attempt to start parsing the terminal latexmath:[T] from
index latexmath:[k] (the second subscript is "to be found"). In traditional
Earley, the input is a sequence of characters, and each terminal
corresponds to a character. Here, we wish to generalize this; a
terminal may correspond to a range of the input. This enables us to
use existing parsers as terminal parsers, which is essential for
composing parsers.

At (l:cd) we introduce the notion of a complete item of the form
latexmath:[( {}_{k} S_{j})]. These items arise from items of the form latexmath:[( X \rightarrow {}_{k} \alpha {}_{j} . )]
which gives a complete item latexmath:[( {}_{k} X_{j})], and parsed terminal items of the
form latexmath:[( {}_{k} T_{j})].

Notation: `k S j` is latexmath:[( {}_{k} S_{j})].

At (l:de) we make the string type abstract. A substring is of the form
latexmath:[(s,i,j)] representing the part of the string latexmath:[s] between latexmath:[i] and
latexmath:[j] where latexmath:[i \le j].

At (l:ef) we encode a grammar as two functions. The first provides the
nt items for a given nt, with input string and index into the
string. The second encodes terminal parsers: given a tm, and a
substring latexmath:[(s,i,j)], return the indexes latexmath:[k] such that latexmath:[(s,i,k)] could
be parsed as tm.

At (l:fg) we define key types for the blocked and complete maps (more
later). Both consist of an index and a symbol.

At (l:gh) we define the map types that we need. From a set of complete
items, we need to identify those for a given start index and
symbol. This is the role of the complete map type `cm_t`. The codomain
of the map is a set of integers latexmath:[j]. If latexmath:[j \in cm(k,S)] then there is
a complete item latexmath:[( {}_{k} S_{j})].

The blocked map allows us to identify, from a set of nt items, those
that are currently blocked at position latexmath:[k] waiting for a parse of
symbol latexmath:[S] to complete. latexmath:[nitm \in bm(k,S)] if latexmath:[nitm] is of the form latexmath:[( X \rightarrow {}_{i} \alpha {}_{k} . S \beta)].

The state of the Earley algorithm is represented as a record with the
following fields:


* `todo_done` is the set of all items that are pending, or have
  already been processed
* `todo` is the list of all items that are pending
* `blocked` is the blocked map
* `complete` is the complete map

At (l:hi) we add an item to the state by adding it to `todo` and
`todo_done`. If the item is already in `todo_done` we leave the state
unchanged.

At (l:ij) we implement the core Earley step. This takes a blocked item
latexmath:[( X \rightarrow {}_{i} \alpha {}_{k} . S \beta)] and a complete item latexmath:[( {}_{k} S_{j})] and forms a new item
of the form latexmath:[( X \rightarrow {}_{i} \alpha S {}_{j} . \beta)]. Note that the latexmath:[\alpha] field is stored in
"reverse" order (to make this operation more efficient).

Notation: latexmath:[S \beta] is the list latexmath:[\beta] with latexmath:[S] cons'ed on. latexmath:[\alpha S] is the
list latexmath:[\alpha] with latexmath:[S] joined on the end.

----
X -> i,as,k,(S bs)   k S j
------------------------- cut
X -> i,(as S),j,bs
----

We then give definitions for adding a complete item to the complete
map, and a blocked item to the blocked map.

At (l:ja) we pull out some common code to process a list of complete
items, all of which have a given key. Processing involves adding each
`citm` to the complete map, and cutting each item against the relevant
blocked items.

At (l:jk) we reach the core `step` part of Earley's algorithm. The
full algorithm repeatedly applies `step` to an initial state until
there are no further `todo` items.

At (l:jp) we at processing an nt item. This item may be complete. If
so, via `process_citms` we record it in the complete map, and process
it against any blocked items with the same key.

At (l:kl) the nt item is not complete. So we record it in the blocked
map. We then try to progress the item by cutting it with all the
current complete items with the same key. It may be that we have yet
to process all or any of the relevant complete items. So we also have
to look at the symbol the nt item is blocked on, and manufacture more
items. This is (l:lm).

At (l:mn) we are processing a terminal item. We use `p_of_tm` to
determine which substrings of the input can be parsed as the terminal
latexmath:[T]. This gives us complete items of the form latexmath:[( {}_{k} T_{j})]. For each
`citm` we then update the complete map and process against blocked
items, using `process_citms`

That concludes the explanation of the core of the algorithm.

At (l:no) we repeatedly apply the step function in a loop until there
are no more items to do.

At (l:op) we apply the loop function to an initial state.

At (l:pq) we give an example for the grammar latexmath:[E \rightarrow E E E |
'1' | \epsilon].


== Complexity

We assume that there is a constant latexmath:[c] such that each invocation of
`p_of_tm` produces at most latexmath:[c * n] results.

As implemented, the algorithm is latexmath:[O(n^3\ log\ n)] because the sets and
maps use OCaml's default sets and maps, which are implemented as
binary trees. However, clearly given an input and a grammar, there are
only a finite number of items that can be in any of the sets or
maps. Thus, we can enumerate these items, and use the enumeration to
implement e.g. a set as an array. This would give the latexmath:[O(n^3)] desired
complexity.

== The OCaml code

[source,ocaml]
--------------------------------------------------
type k_t = int
type i_t = int
type j_t = int


(** Symbols *)

type nt = int
type tm = int
type sym = NT of nt | TM of tm


(** Items *)

(* l:ba *)
type tm_item = {
  k: k_t;
  tm: tm
}

(* l:bc *)
type nt_item = {
  nt: nt;
  i: i_t;
  as_: sym list;
  k: k_t;
  bs: sym list
}

type bitm_t = nt_item  (* bs <> [] *)

(* l:cd *)
(* complete item *)
type citm_t = {
  k: k_t;
  sym: sym;
  j: j_t 
}

type item =   (* items that are being processed *)
  | NTITM of nt_item
  | TMITM of tm_item 


let is_NTITM x = (match x with NTITM _ -> true | _ -> false)
let dest_NTITM x = (match x with NTITM x -> x | _ -> failwith "dest_NTITM")

(* l:de *)
type string_t
type substring_t = (string_t * i_t * j_t)

let string_to_string_t: string -> string_t = (fun s -> Obj.magic s)
let string_t_to_string: string_t -> string = (fun s -> Obj.magic s)

(* l:ef *)
type grammar_t = {
  nt_items_for_nt: nt -> (string_t * int) -> nt_item list;
  p_of_tm: tm -> substring_t -> k_t list
}

type input_t = {
  str: string_t;
  len: int;
}

type ctxt_t = {
  g0: grammar_t;
  i0: input_t
}

(* l:fg *)
type b_key_t = k_t * sym

type c_key_t = k_t * sym

module Int_set = 
  Set.Make(
  struct
    type t = int
    let compare: t -> t -> int = Pervasives.compare
  end)


module Nt_item_set = 
  Set.Make(
  struct
    type t = nt_item
    let compare: t -> t -> int = Pervasives.compare
  end)

module Item_set = struct
  include
  Set.Make(
  struct
    type t = item
    let compare: t -> t -> int = Pervasives.compare
  end)
    
  (* for < 4.02.0 *)
  let of_list: elt list -> t = (
    fun xs -> 
      List.fold_left (fun a b -> add b a) empty xs
  )
end

module Blocked_map =
    Map.Make(
  struct
    type t = b_key_t
    let compare: t -> t -> int = Pervasives.compare
  end)

module Complete_map =
  Map.Make(
  struct
    type t = c_key_t
    let compare: t -> t -> int = Pervasives.compare
  end)


(* l:gh *)
type cm_t = Int_set.t Complete_map.t
type bm_t = Nt_item_set.t Blocked_map.t

type state_t = {
  todo_done: Item_set.t;
  todo: item list;
  blocked: bm_t;
  complete: cm_t
}

(* l:hi *)
let add_todo: item -> state_t -> state_t = (
  fun itm s0 -> (
      match (Item_set.mem itm s0.todo_done) with
      | true -> s0
      | false -> {s0 with
                  todo_done=(Item_set.add itm s0.todo_done);
                  todo=(itm::s0.todo) }
    )
)

(* l:ij *)
let cut: nt_item -> j_t -> nt_item = (
  fun bitm j0 -> (
      let as_ = (List.hd bitm.bs)::bitm.as_ in
      let bs = List.tl bitm.bs in
      let k = j0 in
      let nitm ={bitm with k;as_;bs} in
      nitm
    )
)

let citm_to_key = (fun citm -> (citm.k,citm.sym))

let c_add: citm_t -> cm_t -> cm_t = (
  fun citm cm -> (
      let key = citm_to_key citm in
      let s = try Complete_map.find key cm with Not_found -> Int_set.empty in
      let s' = Int_set.add citm.j s in
      let cm' = Complete_map.add key s' cm in
      cm'
    )
)


let bitm_to_key = (fun (bitm:bitm_t) -> (bitm.k,List.hd bitm.bs))

let b_add: bitm_t -> bm_t -> bm_t = (
  fun bitm bm -> (
      let key = bitm_to_key bitm in
      let s = try Blocked_map.find key bm with Not_found -> Nt_item_set.empty in
      let s' = Nt_item_set.add bitm s in
      let bm' = Blocked_map.add key s' bm in
      bm'
    )        
)

(* l:ja *)
let process_citms key citms s0 = (
  let f5 s1 citm = 
    { s1 with complete=(c_add citm s1.complete) } in
  let s0 = List.fold_left f5 s0 citms in
  (* cut citm against blocked *)
  let bitms = try Blocked_map.find key s0.blocked with Not_found -> Nt_item_set.empty in
  let f8 s1 citm = (
    let f6 bitm s1 = (let nitm = cut bitm citm.j in add_todo (NTITM nitm) s1) in
    let s1 = Nt_item_set.fold f6 bitms s1 in
    s1)
  in
  let s0 = List.fold_left f8 s0 citms in
  s0
)

(* l:jk *)
let step: ctxt_t -> state_t -> state_t = (
fun c0 s0 -> (
match s0.todo with
| [] -> s0  (* finished *)
| itm::rest -> (
    (* process itm *)
    let s0 = { s0 with todo=rest } in
    match itm with
    | NTITM nitm -> (  (* l:jp *)
        let complete = (nitm.bs = []) in
        match complete with
        | true -> (
            let (k,sym,j) = (nitm.i,NT(nitm.nt),nitm.k) in
            let citm : citm_t = {k;sym;j} in
            let key = citm_to_key citm in
            process_citms key [citm] s0
          )
        | false -> (  (* l:kl *)
            (* blocked, so process next sym *)
            let bitm = nitm in
            let (k,sym) = (bitm.k,List.hd nitm.bs) in
            let key = (k,sym) in
            (* record bitm *)
            let s0 = { s0 with blocked=(b_add bitm s0.blocked) } in
            (* process blocked against complete items *)
            let f2 j s1 = (let nitm = cut bitm j in add_todo (NTITM nitm) s1) in
            let js = try Complete_map.find key s0.complete with Not_found -> Int_set.empty in
            let s0 = Int_set.fold f2 js s0 in
            (* now look at symbol we are blocked on *)  (* l:lm *)
            match sym with
            | NT nt -> (
                let nitms = c0.g0.nt_items_for_nt nt (c0.i0.str,k) in
                let f3 s1 nitm = (add_todo (NTITM nitm) s1) in
                let s0 = List.fold_left f3 s0 nitms in
                s0
              )
            | TM tm -> (add_todo (TMITM({k;tm})) s0)
          )
      )  (* NTITM *)
    | TMITM titm -> (  (* l:mn *)
        let tm = titm.tm in
        let k = titm.k in
        let sym = TM tm in
        let p = c0.g0.p_of_tm tm in
        let js = p (c0.i0.str,titm.k,c0.i0.len) in
        let citms = List.map (fun j -> {k;sym;j}) js in
        let key = (k,sym) in
        process_citms key citms s0
      )  (* TMITM *)
  )))


(* l:no *)
let rec earley' ctxt s0 = (
   if s0.todo = [] then s0 else earley' ctxt (step ctxt s0))

(* l:op *)
let earley c0 nt = (
  let nitms = c0.g0.nt_items_for_nt nt (c0.i0.str,0) in
  let todo = List.map (fun x -> NTITM x) nitms in
  let todo_done = Item_set.of_list todo in
  let blocked = Blocked_map.empty in
  let complete = Complete_map.empty in
  let s0 = {todo; todo_done; blocked; complete} in
  earley' c0 s0
)


(* l:pq *)
(** Example E -> E E E | "1" | eps *)

let e' = 1
let e = NT e'
let _1 = TM 2
let eps = TM 3
    
let parse_eps = (fun (s,i,j) -> if i<=j then [i] else [])

let parse_1 = (fun (s,i,j) ->
    (* this terminal parser requires to know string_t *)
    let (s:string) = string_t_to_string s in  
    if i < j && i < String.length s && String.get s i = '1' then 
      [i+1]
    else
      [])

let p_of_tm = (fun tm -> 
    if TM tm=eps then parse_eps
    else if TM tm=_1 then parse_1
    else failwith "p_of_tm: p8t")

  
let g = [
  (e',[e;e;e]);
  (e',[_1]);
  (e',[eps])]

let nt_items_for_nt=(fun nt (s,i) ->
    let _ = assert(nt=e') in
    let as_ = [] in
    let k = i in
    [{nt;i;as_;k;bs=[e;e;e]};
     {nt;i;as_;k;bs=[_1]};
     {nt;i;as_;k;bs=[eps]}])

let g0 = {nt_items_for_nt; p_of_tm}

let str = String.make 10 '1'

let i0 = (
  let len = String.length str in
  let str : string_t = string_to_string_t str in
  { str; len })

let c0 = {g0;i0}

let earley_as_list c0 e' = (
  earley c0 e' |> (fun x -> Item_set.elements x.todo_done
                          |> List.filter is_NTITM |> List.map dest_NTITM))

let earley_rs: nt_item list = earley_as_list c0 e'

let _ = print_endline "Finished"

(* let earley_rs = List.filter (fun (x:nt_item) -> x.k=100) rs *)

(* sample timings: 2.8s for a string of length 200 *)

--------------------------------------------------
